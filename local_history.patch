Index: enclave/app/src/esgx/equote.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/app/src/esgx/equote.rs b/enclave/app/src/esgx/equote.rs
--- a/enclave/app/src/esgx/equote.rs	
+++ b/enclave/app/src/esgx/equote.rs	(date 1664074613514)
@@ -2,12 +2,29 @@
 use std::{self, time};
 use std::thread::sleep;
 
-use sgx_types::*;//sgx_init_quote
+use sgx_types::*;
 
 use failure::Error;
 use hex::FromHex;
 
-use crate::ocalls_u::{ecall_get_registration_quote, ecall_get_signing_address};
+
+#[no_mangle]
+extern "C" {
+    pub fn ecall_get_signing_address(eid: sgx_enclave_id_t, arr: *mut [u8; 20usize]) -> sgx_status_t;
+
+    pub fn ecall_get_registration_quote(eid: sgx_enclave_id_t, retval: *mut sgx_status_t,
+                                        target_info: *const sgx_target_info_t, report: *mut sgx_report_t) -> sgx_status_t;
+
+    pub fn sgx_init_quote(p_target_info: *mut sgx_target_info_t, p_gid: *mut sgx_epid_group_id_t) -> sgx_status_t;
+
+    pub fn sgx_calc_quote_size(p_sig_rl: *const uint8_t, sig_rl_size: uint32_t, p_quote_size: *mut uint32_t) -> sgx_status_t;
+
+    pub fn sgx_get_quote(p_report: *const sgx_report_t, quote_type: sgx_quote_sign_type_t,
+                         p_spid: *const sgx_spid_t, p_nonce: *const sgx_quote_nonce_t, p_sig_rl: *const uint8_t,
+                         sig_rl_size: uint32_t, p_qe_report: *mut sgx_report_t, p_quote: *mut sgx_quote_t,
+                         quote_size: uint32_t) -> sgx_status_t;
+}
+
 // this struct is returned during the process registration back to the surface.
 // quote: the base64 encoded quote
 // address : the clear text public key for ecdsa signing and registration
Index: enclave/app/src/main.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/app/src/main.rs b/enclave/app/src/main.rs
--- a/enclave/app/src/main.rs	
+++ b/enclave/app/src/main.rs	(date 1664075054458)
@@ -34,29 +34,24 @@
 pub extern crate log;
 #[macro_use]
 extern crate log_derive;
-
-use std::env;
-use sgx_types::*;
-use sgx_urts::SgxEnclave;
-
-// extern crate enigma_types;
-// pub extern crate enigma_tools_u;
-// extern crate enigma_tools_m;
-// extern crate enigma_crypto;
-
 extern crate base64;
 extern crate openssl;
 extern crate reqwest;
 
+use std::env;
+
+use sgx_types::*;
+use sgx_urts::SgxEnclave;
+
+use futures::Future;
+use networking::{ipc_listener, IpcListener};
+
 pub mod attestation;
 pub mod networking;
 pub mod ocalls_u;
 pub mod esgx;
 pub mod oram;
 
-use futures::Future;
-use networking::{ipc_listener, IpcListener};
-
 static ENCLAVE_FILE: &'static str = "enclave.signed.so";
 
 
Index: enclave/app/src/oram.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/app/src/oram.rs b/enclave/app/src/oram.rs
--- a/enclave/app/src/oram.rs	
+++ b/enclave/app/src/oram.rs	(date 1664079865092)
@@ -16,7 +16,7 @@
 ///
 /// This is not actually part of the public interface of the crate, the only
 /// thing exported by the crate is the enclave EDL functions
-struct UntrustedAllocation {
+pub struct UntrustedAllocation {
     /// The number of data and meta items stored in this allocation
     count: usize,
     /// The size of a data item in bytes
@@ -124,6 +124,7 @@
 
 // These extern "C" functions must match edl file
 
+
 /// # Safety
 ///
 /// meta_size and data_size must be divisible by 8
@@ -135,6 +136,8 @@
     meta_size: u64,
     id_out: *mut u64,
 ) {
+    assert!(1>2,"fudgesickles3");
+    println!("untrusted allocate_oram_storage");
     let result = Box::new(UntrustedAllocation::new(
         count as usize,
         data_size as usize,
@@ -144,7 +147,6 @@
     #[cfg(debug_assertions)]
     debug_checks::add_id(id);
     *id_out = id;
-
 }
 
 /// # Safety
@@ -152,6 +154,8 @@
 /// id must be a valid id previously returned by allocate_oram_storage
 #[no_mangle]
 pub unsafe extern "C" fn release_oram_storage(id: u64) {
+    assert!(1>2,"fudgesickles2");
+    println!("untrusted release_oram_storage");
     let ptr: *mut UntrustedAllocation = core::mem::transmute(id);
     assert!(
         !(*ptr).critical_section_flag.swap(true, Ordering::SeqCst),
@@ -188,6 +192,8 @@
     metabuf: *mut u64,
     metabuf_len: usize,
 ) {
+    println!("untrusted checkout_oram_storage");
+    assert!(1>2,"fudgesickles3");
     #[cfg(debug_assertions)]
     debug_checks::check_id(id);
     let ptr: *const UntrustedAllocation = core::mem::transmute(id);
@@ -260,6 +266,8 @@
     metabuf: *const u64,
     metabuf_len: usize,
 ) {
+    assert!(1>2,"fudgesickles0");
+    println!("untrusted checkin_oram_storage");
     #[cfg(debug_assertions)]
     debug_checks::check_id(id);
     let ptr: *const UntrustedAllocation = core::mem::transmute(id);
Index: enclave/app/src/networking/ipc_listener.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/app/src/networking/ipc_listener.rs b/enclave/app/src/networking/ipc_listener.rs
--- a/enclave/app/src/networking/ipc_listener.rs	
+++ b/enclave/app/src/networking/ipc_listener.rs	(date 1664075054451)
@@ -61,7 +61,6 @@
     use rmp_serde::Deserializer;
     use serde::Deserialize;
     use serde_json::Value;
-    // use enigma_types::{EnclaveReturn};
 
     extern {
         fn ecall_init_user_db(
@@ -72,6 +71,15 @@
     }
 
 
+    extern {
+        fn ecall_get_encryption_pubkey(
+            eid: sgx_enclave_id_t,
+            sig: *mut [u8; 65usize],
+            arr: *mut [u8; 64usize]) -> sgx_status_t;
+    }
+
+
+
     extern {
         fn ecall_add_personal_data(
             eid: sgx_enclave_id_t,
@@ -114,10 +122,6 @@
         ) -> sgx_status_t;
     }
 
-    extern {
-        fn ecall_get_encryption_pubkey(eid: sgx_enclave_id_t, sig: *mut [u8; 65usize], arr: *mut [u8; 64usize]) -> sgx_status_t;
-    }
-
     type ResponseResult = Result<IpcResponse, Error>;
 
     #[derive(Serialize, Deserialize)]
@@ -193,8 +197,6 @@
         let mut size: usize = 4096;
         let mut size_ptr: *mut usize = &mut size;
         let mut sig = [0u8; 65];
-        println!("get_enclave_data1");
-
         let status = unsafe {
             ecall_get_enclave_data(
                 eid,
@@ -204,27 +206,20 @@
                 size_ptr
             )
         };
-        println!("get_enclave_data2");
 
         let box_ptr = serialized_ptr as *mut Box<[u8]>;
-        println!("get_enclave_data3");
         let part = unsafe { Box::from_raw(box_ptr) };
-        println!("get_enclave_data4");
         let data_size = unsafe { *size_ptr };
-        println!("get_enclave_data5");
         let result;
-        if(ret == sgx_status_t::SGX_SUCCESS) {
-            println!("get_enclave_data6");
+        if ret == sgx_status_t::SGX_SUCCESS {
             let datahex = part.to_hex();
             //TODO delete
             println!("datahex {:?} {:?}",datahex.len(),datahex);
             let signature = sig.to_hex();
             result = IpcResults::EnclaveData{ status: Status::Passed, data: datahex, signature};
         } else {
-            println!("get_enclave_data7");
             result = IpcResults::EnclaveData{ status: Status::Failed, data: "".to_string(), signature: "".to_string() };
         }
-        println!("get_enclave_data8");
 
         Ok(IpcResponse::GetEnclaveData { result })
     }
@@ -253,7 +248,7 @@
         let part = unsafe { Box::from_raw(box_ptr) };
         let data_size = unsafe { *size_ptr };
         let result;
-        if(ret == sgx_status_t::SGX_SUCCESS) {
+        if ret == sgx_status_t::SGX_SUCCESS {
             let datahex = part.to_hex();
             //TODO delete
             println!("datahex {:?} {:?}",datahex.len(),datahex);
@@ -273,7 +268,7 @@
 
         let mut ret = sgx_status_t::SGX_SUCCESS;
         let db = input.from_hex()?;
-        println!("init_user_db {:?} {:?}",db.len(),db);
+        println!("app.init_user_db {:?} {:?}",db.len(),db);
 
         unsafe { ecall_init_user_db(eid,
                                          &mut ret as *mut sgx_status_t,
@@ -281,7 +276,7 @@
                                          db.len()) };
 
         let result;
-        if(ret == sgx_status_t::SGX_SUCCESS) {
+        if ret == sgx_status_t::SGX_SUCCESS {
             result = IpcResults::InitUserDB { status: Status::Passed };
         } else {
             result = IpcResults::InitUserDB { status: Status::Failed };
@@ -342,7 +337,7 @@
          let part = unsafe { Box::from_raw(box_ptr) };
          let hm_size = unsafe { *size_ptr };
          let result;
-         if(ret == sgx_status_t::SGX_SUCCESS) {
+         if ret == sgx_status_t::SGX_SUCCESS {
              let hmhex = part.to_hex();
              println!("hmhex {:?} {:?}",hmhex.len(),hmhex);
              let signature = sig.to_hex();
Index: enclave/app/src/ocalls_u.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/app/src/ocalls_u.rs b/enclave/app/src/ocalls_u.rs
--- a/enclave/app/src/ocalls_u.rs	
+++ b/enclave/app/src/ocalls_u.rs	(date 1664079865106)
@@ -1,35 +1,17 @@
 use std::slice;
 
-use sgx_types::{sgx_enclave_id_t, sgx_status_t, sgx_target_info_t, sgx_report_t, uint8_t, uint32_t};
-// use sgx_types::*;
+use oram::UntrustedAllocation;
+use std::{boxed::Box};
 
-//use crate::esgx::general;
 
 #[no_mangle]
-pub unsafe extern "C" fn ocall_save_to_memory(data_ptr: *const u8, data_len: usize) -> u64 {
-    let data = slice::from_raw_parts(data_ptr, data_len).to_vec();
+pub unsafe extern "C" fn ocall_save_to_memory(
+    // data_ptr: *const u8, data_len: usize
+) -> u64 {
+    // let mut data : Vec<u8> = slice::from_raw_parts(data_ptr, data_len).to_vec();
+    // let ptr = Box::into_raw(Box::new(data.into_boxed_slice())) as *const u8;
+    let data: Vec<u8> = Vec::new();
     let ptr = Box::into_raw(Box::new(data.into_boxed_slice())) as *const u8;
+    println!("untrusted ocall_save_to_memory");
     ptr as u64
-}
-
-
-#[no_mangle]
-extern "C" {
-    pub fn ecall_get_signing_address(eid: sgx_enclave_id_t, arr: *mut [u8; 20usize]) -> sgx_status_t;
-
-}
-
-#[no_mangle]
-extern "C" {
-    pub fn ecall_get_registration_quote(eid: sgx_enclave_id_t, retval: *mut sgx_status_t,
-                                        target_info: *const sgx_target_info_t, report: *mut sgx_report_t) -> sgx_status_t;
-
-    // pub fn sgx_init_quote(p_target_info: *mut sgx_target_info_t, p_gid: *mut sgx_epid_group_id_t) -> sgx_status_t;
-    //
-    // pub fn sgx_calc_quote_size(p_sig_rl: *const uint8_t, sig_rl_size: uint32_t, p_quote_size: *mut uint32_t) -> sgx_status_t;
-    //
-    // pub fn sgx_get_quote(p_report: *const sgx_report_t, quote_type: sgx_quote_sign_type_t,
-    //                      p_spid: *const sgx_spid_t, p_nonce: *const sgx_quote_nonce_t, p_sig_rl: *const uint8_t,
-    //                      sig_rl_size: uint32_t, p_qe_report: *mut sgx_report_t, p_quote: *mut sgx_quote_t,
-    //                      quote_size: uint32_t) -> sgx_status_t;
 }
\ No newline at end of file
Index: enclave/app/target/release/.fingerprint/heatmap-app-174e37f986548577/bin-heatmap-app.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/app/target/release/.fingerprint/heatmap-app-174e37f986548577/bin-heatmap-app.json b/enclave/app/target/release/.fingerprint/heatmap-app-174e37f986548577/bin-heatmap-app.json
--- a/enclave/app/target/release/.fingerprint/heatmap-app-174e37f986548577/bin-heatmap-app.json	
+++ b/enclave/app/target/release/.fingerprint/heatmap-app-174e37f986548577/bin-heatmap-app.json	(date 1664077245290)
@@ -1,1 +1,1 @@
-{"rustc":16864309158671632917,"features":"[]","target":1072391203638640554,"profile":6269190295429226618,"path":1036222786711178230,"deps":[[788482587857998339,"percent_encoding",false,3650477763652017487],[933630640346235945,"build_script_build",false,17214115641971336042],[1086402218604136719,"serde",false,12730600079511306676],[1175692184310149643,"openssl_sys",false,17184107073718406283],[1544760799344881691,"tokio_zmq",false,1520670259634943219],[3767579130572673224,"log_derive",false,17128452853874518611],[4573644269895370759,"futures",false,3263869598838016366],[6596691954574338700,"zmq",false,14930949676767932552],[6597564319215557603,"log",false,18145865083311233865],[6648979964085216508,"sgx_urts",false,9639591181288798785],[6685014296130524576,"lazy_static",false,12910414502533943197],[7081106715254084602,"sgx_types",false,782722314870779489],[7871556428063912397,"reqwest",false,12392639383883974189],[9350316669271096348,"rustc_hex",false,17000313827666444875],[10660180639904413679,"serde_repr",false,15857380792096421674],[11252396326835065723,"rmp_serde",false,17809801656004249794],[11297834647425509777,"base64",false,12202662911300834631],[15664977366689157140,"dirs",false,10586522587421812295],[15926663815230890737,"failure",false,14251144205273789232],[16200220845015685767,"openssl",false,2969240263840743751],[16735575723344940554,"serde_json",false,3091823489361146328]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/heatmap-app-174e37f986548577/dep-bin-heatmap-app"}}],"rustflags":[],"metadata":16371177206910596745,"config":2202906307356721367,"compile_kind":0}
\ No newline at end of file
+{"rustc":16864309158671632917,"features":"[]","target":1072391203638640554,"profile":6269190295429226618,"path":1036222786711178230,"deps":[[788482587857998339,"percent_encoding",false,3650477763652017487],[933630640346235945,"build_script_build",false,15086242944441503516],[1086402218604136719,"serde",false,12730600079511306676],[1175692184310149643,"openssl_sys",false,6869077304592452481],[1544760799344881691,"tokio_zmq",false,7924890721985603183],[3767579130572673224,"log_derive",false,17128452853874518611],[4573644269895370759,"futures",false,3263869598838016366],[6596691954574338700,"zmq",false,7673709077275408303],[6597564319215557603,"log",false,18145865083311233865],[6648979964085216508,"sgx_urts",false,9639591181288798785],[6685014296130524576,"lazy_static",false,12910414502533943197],[7081106715254084602,"sgx_types",false,782722314870779489],[7871556428063912397,"reqwest",false,6931309848394954159],[9350316669271096348,"rustc_hex",false,17000313827666444875],[10660180639904413679,"serde_repr",false,15857380792096421674],[11252396326835065723,"rmp_serde",false,17809801656004249794],[11297834647425509777,"base64",false,12202662911300834631],[15664977366689157140,"dirs",false,10586522587421812295],[15926663815230890737,"failure",false,14251144205273789232],[16200220845015685767,"openssl",false,4625763531342311951],[16735575723344940554,"serde_json",false,3091823489361146328]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/heatmap-app-174e37f986548577/dep-bin-heatmap-app"}}],"rustflags":[],"metadata":16371177206910596745,"config":2202906307356721367,"compile_kind":0}
\ No newline at end of file
Index: enclave/app/target/release/.fingerprint/heatmap-app-174e37f986548577/output-bin-heatmap-app
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/app/target/release/.fingerprint/heatmap-app-174e37f986548577/output-bin-heatmap-app b/enclave/app/target/release/.fingerprint/heatmap-app-174e37f986548577/output-bin-heatmap-app
--- a/enclave/app/target/release/.fingerprint/heatmap-app-174e37f986548577/output-bin-heatmap-app	
+++ b/enclave/app/target/release/.fingerprint/heatmap-app-174e37f986548577/output-bin-heatmap-app	(date 1664077245253)
@@ -1,15 +1,18 @@
-{"message":"unused import: `rmp_serde::Deserializer`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":2393,"byte_end":2416,"line_start":61,"line_end":61,"column_start":9,"column_end":32,"is_primary":true,"text":[{"text":"    use rmp_serde::Deserializer;","highlight_start":9,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":2389,"byte_end":2417,"line_start":61,"line_end":61,"column_start":5,"column_end":33,"is_primary":true,"text":[{"text":"    use rmp_serde::Deserializer;","highlight_start":5,"highlight_end":33}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `rmp_serde::Deserializer`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:61:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    use rmp_serde::Deserializer;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
-{"message":"unused import: `serde_json::Value`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":2454,"byte_end":2471,"line_start":63,"line_end":63,"column_start":9,"column_end":26,"is_primary":true,"text":[{"text":"    use serde_json::Value;","highlight_start":9,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":2450,"byte_end":2472,"line_start":63,"line_end":63,"column_start":5,"column_end":27,"is_primary":true,"text":[{"text":"    use serde_json::Value;","highlight_start":5,"highlight_end":27}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `serde_json::Value`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:63:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m63\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    use serde_json::Value;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
-{"message":"unnecessary parentheses around `if` condition","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":7973,"byte_end":7974,"line_start":216,"line_end":216,"column_start":11,"column_end":12,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":11,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/networking/ipc_listener.rs","byte_start":8006,"byte_end":8007,"line_start":216,"line_end":216,"column_start":44,"column_end":45,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":44,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_parens)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":7973,"byte_end":7974,"line_start":216,"line_end":216,"column_start":11,"column_end":12,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":11,"highlight_end":12}],"label":null,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/networking/ipc_listener.rs","byte_start":8006,"byte_end":8007,"line_start":216,"line_end":216,"column_start":44,"column_end":45,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":44,"highlight_end":45}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary parentheses around `if` condition\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:216:11\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m216\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if(ret == sgx_status_t::SGX_SUCCESS) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_parens)]` on by default\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove these parentheses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m216\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        if\u001b[0m\u001b[0m\u001b[38;5;9m(\u001b[0m\u001b[0mret == sgx_status_t::SGX_SUCCESS\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m216\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        if\u001b[0m\u001b[0m\u001b[38;5;10m \u001b[0m\u001b[0mret == sgx_status_t::SGX_SUCCESS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\n"}
-{"message":"unnecessary parentheses around `if` condition","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":9357,"byte_end":9358,"line_start":255,"line_end":255,"column_start":11,"column_end":12,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":11,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/networking/ipc_listener.rs","byte_start":9390,"byte_end":9391,"line_start":255,"line_end":255,"column_start":44,"column_end":45,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":44,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":9357,"byte_end":9358,"line_start":255,"line_end":255,"column_start":11,"column_end":12,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":11,"highlight_end":12}],"label":null,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/networking/ipc_listener.rs","byte_start":9390,"byte_end":9391,"line_start":255,"line_end":255,"column_start":44,"column_end":45,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":44,"highlight_end":45}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary parentheses around `if` condition\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:255:11\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m255\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if(ret == sgx_status_t::SGX_SUCCESS) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove these parentheses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m255\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        if\u001b[0m\u001b[0m\u001b[38;5;9m(\u001b[0m\u001b[0mret == sgx_status_t::SGX_SUCCESS\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m255\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        if\u001b[0m\u001b[0m\u001b[38;5;10m \u001b[0m\u001b[0mret == sgx_status_t::SGX_SUCCESS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\n"}
-{"message":"unnecessary parentheses around `if` condition","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":10412,"byte_end":10413,"line_start":283,"line_end":283,"column_start":11,"column_end":12,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":11,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/networking/ipc_listener.rs","byte_start":10445,"byte_end":10446,"line_start":283,"line_end":283,"column_start":44,"column_end":45,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":44,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":10412,"byte_end":10413,"line_start":283,"line_end":283,"column_start":11,"column_end":12,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":11,"highlight_end":12}],"label":null,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/networking/ipc_listener.rs","byte_start":10445,"byte_end":10446,"line_start":283,"line_end":283,"column_start":44,"column_end":45,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":44,"highlight_end":45}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary parentheses around `if` condition\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:283:11\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m283\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if(ret == sgx_status_t::SGX_SUCCESS) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove these parentheses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m283\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        if\u001b[0m\u001b[0m\u001b[38;5;9m(\u001b[0m\u001b[0mret == sgx_status_t::SGX_SUCCESS\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m283\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        if\u001b[0m\u001b[0m\u001b[38;5;10m \u001b[0m\u001b[0mret == sgx_status_t::SGX_SUCCESS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\n"}
-{"message":"unnecessary parentheses around `if` condition","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":11643,"byte_end":11644,"line_start":312,"line_end":312,"column_start":11,"column_end":12,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":11,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/networking/ipc_listener.rs","byte_start":11676,"byte_end":11677,"line_start":312,"line_end":312,"column_start":44,"column_end":45,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":44,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":11643,"byte_end":11644,"line_start":312,"line_end":312,"column_start":11,"column_end":12,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":11,"highlight_end":12}],"label":null,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/networking/ipc_listener.rs","byte_start":11676,"byte_end":11677,"line_start":312,"line_end":312,"column_start":44,"column_end":45,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":44,"highlight_end":45}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary parentheses around `if` condition\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:312:11\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m312\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if(ret == sgx_status_t::SGX_SUCCESS) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove these parentheses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m312\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        if\u001b[0m\u001b[0m\u001b[38;5;9m(\u001b[0m\u001b[0mret == sgx_status_t::SGX_SUCCESS\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m312\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        if\u001b[0m\u001b[0m\u001b[38;5;10m \u001b[0m\u001b[0mret == sgx_status_t::SGX_SUCCESS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\n"}
-{"message":"unnecessary parentheses around `if` condition","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":12701,"byte_end":12702,"line_start":344,"line_end":344,"column_start":12,"column_end":13,"is_primary":true,"text":[{"text":"         if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":12,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/networking/ipc_listener.rs","byte_start":12734,"byte_end":12735,"line_start":344,"line_end":344,"column_start":45,"column_end":46,"is_primary":true,"text":[{"text":"         if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":45,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":12701,"byte_end":12702,"line_start":344,"line_end":344,"column_start":12,"column_end":13,"is_primary":true,"text":[{"text":"         if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":12,"highlight_end":13}],"label":null,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/networking/ipc_listener.rs","byte_start":12734,"byte_end":12735,"line_start":344,"line_end":344,"column_start":45,"column_end":46,"is_primary":true,"text":[{"text":"         if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":45,"highlight_end":46}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary parentheses around `if` condition\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:344:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m344\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         if(ret == sgx_status_t::SGX_SUCCESS) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove these parentheses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m344\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m         if\u001b[0m\u001b[0m\u001b[38;5;9m(\u001b[0m\u001b[0mret == sgx_status_t::SGX_SUCCESS\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m344\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m         if\u001b[0m\u001b[0m\u001b[38;5;10m \u001b[0m\u001b[0mret == sgx_status_t::SGX_SUCCESS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\n"}
-{"message":"unused imports: `uint32_t`, `uint8_t`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/ocalls_u.rs","byte_start":98,"byte_end":105,"line_start":3,"line_end":3,"column_start":82,"column_end":89,"is_primary":true,"text":[{"text":"use sgx_types::{sgx_enclave_id_t, sgx_status_t, sgx_target_info_t, sgx_report_t, uint8_t, uint32_t};","highlight_start":82,"highlight_end":89}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ocalls_u.rs","byte_start":107,"byte_end":115,"line_start":3,"line_end":3,"column_start":91,"column_end":99,"is_primary":true,"text":[{"text":"use sgx_types::{sgx_enclave_id_t, sgx_status_t, sgx_target_info_t, sgx_report_t, uint8_t, uint32_t};","highlight_start":91,"highlight_end":99}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src/ocalls_u.rs","byte_start":96,"byte_end":115,"line_start":3,"line_end":3,"column_start":80,"column_end":99,"is_primary":true,"text":[{"text":"use sgx_types::{sgx_enclave_id_t, sgx_status_t, sgx_target_info_t, sgx_report_t, uint8_t, uint32_t};","highlight_start":80,"highlight_end":99}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `uint32_t`, `uint8_t`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/ocalls_u.rs:3:82\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse sgx_types::{sgx_enclave_id_t, sgx_status_t, sgx_target_info_t, sgx_report_t, uint8_t, uint32_t};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n\n"}
+{"message":"unused import: `rmp_serde::Deserializer`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":2397,"byte_end":2420,"line_start":61,"line_end":61,"column_start":9,"column_end":32,"is_primary":true,"text":[{"text":"    use rmp_serde::Deserializer;","highlight_start":9,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":2393,"byte_end":2421,"line_start":61,"line_end":61,"column_start":5,"column_end":33,"is_primary":true,"text":[{"text":"    use rmp_serde::Deserializer;","highlight_start":5,"highlight_end":33}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `rmp_serde::Deserializer`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:61:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    use rmp_serde::Deserializer;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
+{"message":"unused import: `serde_json::Value`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":2458,"byte_end":2475,"line_start":63,"line_end":63,"column_start":9,"column_end":26,"is_primary":true,"text":[{"text":"    use serde_json::Value;","highlight_start":9,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":2454,"byte_end":2476,"line_start":63,"line_end":63,"column_start":5,"column_end":27,"is_primary":true,"text":[{"text":"    use serde_json::Value;","highlight_start":5,"highlight_end":27}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `serde_json::Value`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:63:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m63\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    use serde_json::Value;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
+{"message":"unnecessary parentheses around `if` condition","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":11364,"byte_end":11365,"line_start":308,"line_end":308,"column_start":11,"column_end":12,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":11,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/networking/ipc_listener.rs","byte_start":11397,"byte_end":11398,"line_start":308,"line_end":308,"column_start":44,"column_end":45,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":44,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_parens)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":11364,"byte_end":11365,"line_start":308,"line_end":308,"column_start":11,"column_end":12,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":11,"highlight_end":12}],"label":null,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/networking/ipc_listener.rs","byte_start":11397,"byte_end":11398,"line_start":308,"line_end":308,"column_start":44,"column_end":45,"is_primary":true,"text":[{"text":"        if(ret == sgx_status_t::SGX_SUCCESS) {","highlight_start":44,"highlight_end":45}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary parentheses around `if` condition\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:308:11\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m308\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if(ret == sgx_status_t::SGX_SUCCESS) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_parens)]` on by default\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove these parentheses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m308\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        if\u001b[0m\u001b[0m\u001b[38;5;9m(\u001b[0m\u001b[0mret == sgx_status_t::SGX_SUCCESS\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m308\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        if\u001b[0m\u001b[0m\u001b[38;5;10m \u001b[0m\u001b[0mret == sgx_status_t::SGX_SUCCESS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\n"}
+{"message":"unused import: `std::slice`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/ocalls_u.rs","byte_start":4,"byte_end":14,"line_start":1,"line_end":1,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"use std::slice;","highlight_start":5,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/ocalls_u.rs","byte_start":0,"byte_end":15,"line_start":1,"line_end":1,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"use std::slice;","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::slice`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/ocalls_u.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse std::slice;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n\n"}
+{"message":"unused import: `oram::UntrustedAllocation`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/ocalls_u.rs","byte_start":21,"byte_end":46,"line_start":3,"line_end":3,"column_start":5,"column_end":30,"is_primary":true,"text":[{"text":"use oram::UntrustedAllocation;","highlight_start":5,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/ocalls_u.rs","byte_start":17,"byte_end":47,"line_start":3,"line_end":3,"column_start":1,"column_end":31,"is_primary":true,"text":[{"text":"use oram::UntrustedAllocation;","highlight_start":1,"highlight_end":31}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `oram::UntrustedAllocation`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/ocalls_u.rs:3:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse oram::UntrustedAllocation;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
 {"message":"unnecessary parentheses around type","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"src/esgx/general.rs","byte_start":572,"byte_end":573,"line_start":20,"line_end":20,"column_start":34,"column_end":35,"is_primary":true,"text":[{"text":"                    -> SgxResult<(SgxEnclave)> {","highlight_start":34,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/esgx/general.rs","byte_start":583,"byte_end":584,"line_start":20,"line_end":20,"column_start":45,"column_end":46,"is_primary":true,"text":[{"text":"                    -> SgxResult<(SgxEnclave)> {","highlight_start":45,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"src/esgx/general.rs","byte_start":572,"byte_end":573,"line_start":20,"line_end":20,"column_start":34,"column_end":35,"is_primary":true,"text":[{"text":"                    -> SgxResult<(SgxEnclave)> {","highlight_start":34,"highlight_end":35}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/esgx/general.rs","byte_start":583,"byte_end":584,"line_start":20,"line_end":20,"column_start":45,"column_end":46,"is_primary":true,"text":[{"text":"                    -> SgxResult<(SgxEnclave)> {","highlight_start":45,"highlight_end":46}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary parentheses around type\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/esgx/general.rs:20:34\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    -> SgxResult<(SgxEnclave)> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove these parentheses\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                    -> SgxResult<\u001b[0m\u001b[0m\u001b[38;5;9m(\u001b[0m\u001b[0mSgxEnclave\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m> {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                    -> SgxResult<SgxEnclave> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\n"}
-{"message":"attribute should be applied to a free function, impl method or static","code":{"code":"unused_attributes","explanation":null},"level":"warning","spans":[{"file_name":"src/ocalls_u.rs","byte_start":451,"byte_end":568,"line_start":17,"line_end":20,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"extern \"C\" {","highlight_start":1,"highlight_end":13},{"text":"    pub fn ecall_get_signing_address(eid: sgx_enclave_id_t, arr: *mut [u8; 20usize]) -> sgx_status_t;","highlight_start":1,"highlight_end":102},{"text":"","highlight_start":1,"highlight_end":1},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"not a free function, impl method or static","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ocalls_u.rs","byte_start":438,"byte_end":450,"line_start":16,"line_end":16,"column_start":1,"column_end":13,"is_primary":true,"text":[{"text":"#[no_mangle]","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_attributes)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!","code":null,"level":"warning","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: attribute should be applied to a free function, impl method or static\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/ocalls_u.rs:16:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m#[no_mangle]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mextern \"C\" {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn ecall_get_signing_address(eid: sgx_enclave_id_t, arr: *mut [u8; 20usize]) -> sgx_status_t;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mnot a free function, impl method or static\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_attributes)]` on by default\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\u001b[0m\n\n"}
-{"message":"attribute should be applied to a free function, impl method or static","code":{"code":"unused_attributes","explanation":null},"level":"warning","spans":[{"file_name":"src/ocalls_u.rs","byte_start":583,"byte_end":1459,"line_start":23,"line_end":35,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"extern \"C\" {","highlight_start":1,"highlight_end":13},{"text":"    pub fn ecall_get_registration_quote(eid: sgx_enclave_id_t, retval: *mut sgx_status_t,","highlight_start":1,"highlight_end":90},{"text":"                                        target_info: *const sgx_target_info_t, report: *mut sgx_report_t) -> sgx_status_t;","highlight_start":1,"highlight_end":123},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // pub fn sgx_init_quote(p_target_info: *mut sgx_target_info_t, p_gid: *mut sgx_epid_group_id_t) -> sgx_status_t;","highlight_start":1,"highlight_end":118},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    // pub fn sgx_calc_quote_size(p_sig_rl: *const uint8_t, sig_rl_size: uint32_t, p_quote_size: *mut uint32_t) -> sgx_status_t;","highlight_start":1,"highlight_end":129},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    // pub fn sgx_get_quote(p_report: *const sgx_report_t, quote_type: sgx_quote_sign_type_t,","highlight_start":1,"highlight_end":94},{"text":"    //                      p_spid: *const sgx_spid_t, p_nonce: *const sgx_quote_nonce_t, p_sig_rl: *const uint8_t,","highlight_start":1,"highlight_end":116},{"text":"    //                      sig_rl_size: uint32_t, p_qe_report: *mut sgx_report_t, p_quote: *mut sgx_quote_t,","highlight_start":1,"highlight_end":110},{"text":"    //                      quote_size: uint32_t) -> sgx_status_t;","highlight_start":1,"highlight_end":67},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"not a free function, impl method or static","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ocalls_u.rs","byte_start":570,"byte_end":582,"line_start":22,"line_end":22,"column_start":1,"column_end":13,"is_primary":true,"text":[{"text":"#[no_mangle]","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!","code":null,"level":"warning","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: attribute should be applied to a free function, impl method or static\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/ocalls_u.rs:22:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m#[no_mangle]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mextern \"C\" {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn ecall_get_registration_quote(eid: sgx_enclave_id_t, retval: *mut sgx_status_t,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                        target_info: *const sgx_target_info_t, report: *mut sgx_report_t) -> sgx_status_t;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m26\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    //                      quote_size: uint32_t) -> sgx_status_t;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mnot a free function, impl method or static\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\u001b[0m\n\n"}
-{"message":"`#[macro_use]` only has an effect on `extern crate` and modules","code":{"code":"unused_attributes","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":2249,"byte_end":2261,"line_start":57,"line_end":57,"column_start":5,"column_end":17,"is_primary":true,"text":[{"text":"    #[macro_use]  use failure::Error;","highlight_start":5,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: `#[macro_use]` only has an effect on `extern crate` and modules\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:57:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    #[macro_use]  use failure::Error;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\n\n"}
-{"message":"`match` arms have incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":1858,"byte_end":1889,"line_start":44,"line_end":44,"column_start":35,"column_end":66,"is_primary":true,"text":[{"text":"            IpcRequest::Error => {IpcResponse::Error{msg: msg.id}}","highlight_start":35,"highlight_end":66}],"label":"expected enum `Result`, found enum `messages::IpcResponse`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/networking/ipc_listener.rs","byte_start":1791,"byte_end":1822,"line_start":43,"line_end":43,"column_start":44,"column_end":75,"is_primary":false,"text":[{"text":"            IpcRequest::RetrieveHeatmap => handling::retrieve_heatmap(eid),","highlight_start":44,"highlight_end":75}],"label":"this and all prior arms are found to be of type `Result<messages::IpcResponse, failure::Error>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/networking/ipc_listener.rs","byte_start":1211,"byte_end":1900,"line_start":36,"line_end":45,"column_start":28,"column_end":10,"is_primary":false,"text":[{"text":"        let response_msg = match msg.request {","highlight_start":28,"highlight_end":47},{"text":"            IpcRequest::GetEnclaveReport => handling::get_enclave_report(eid, spid, api_key, retries),","highlight_start":1,"highlight_end":103},{"text":"            IpcRequest::GetEnclavePublicKey => handling::get_enclave_publickey(eid),","highlight_start":1,"highlight_end":85},{"text":"            IpcRequest::GetEnclaveData => handling::get_enclave_data(eid),","highlight_start":1,"highlight_end":75},{"text":"            IpcRequest::GetAuditData => handling::get_audit_data(eid),","highlight_start":1,"highlight_end":71},{"text":"            IpcRequest::InitUserDB { user_db } => handling::init_user_db(&user_db, eid),","highlight_start":1,"highlight_end":89},{"text":"            IpcRequest::AddPersonalData { input } => handling::add_personal_data(input, eid),","highlight_start":1,"highlight_end":94},{"text":"            IpcRequest::RetrieveHeatmap => handling::retrieve_heatmap(eid),","highlight_start":1,"highlight_end":76},{"text":"            IpcRequest::Error => {IpcResponse::Error{msg: msg.id}}","highlight_start":1,"highlight_end":67},{"text":"        };","highlight_start":1,"highlight_end":10}],"label":"`match` arms have incompatible types","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected enum `Result<messages::IpcResponse, failure::Error>`\n   found enum `messages::IpcResponse`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try using a variant of the expected enum","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":1857,"byte_end":1890,"line_start":44,"line_end":44,"column_start":34,"column_end":67,"is_primary":true,"text":[{"text":"            IpcRequest::Error => {IpcResponse::Error{msg: msg.id}}","highlight_start":34,"highlight_end":67}],"label":null,"suggested_replacement":"serde::__private::Ok({IpcResponse::Error{msg: msg.id}})","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: `match` arms have incompatible types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:44:35\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m36\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m        let response_msg = match msg.request {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m____________________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            IpcRequest::GetEnclaveReport => handling::get_enclave_report(eid, spid, api_key, retries),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            IpcRequest::GetEnclavePublicKey => handling::get_enclave_publickey(eid),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            IpcRequest::GetEnclaveData => handling::get_enclave_data(eid),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m43\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            IpcRequest::RetrieveHeatmap => handling::retrieve_heatmap(eid),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis and all prior arms are found to be of type `Result<messages::IpcResponse, failure::Error>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            IpcRequest::Error => {IpcResponse::Error{msg: msg.id}}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected enum `Result`, found enum `messages::IpcResponse`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: try using a variant of the expected enum: `serde::__private::Ok({IpcResponse::Error{msg: msg.id}})`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        };\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`match` arms have incompatible types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected enum `\u001b[0m\u001b[0m\u001b[1mResult<\u001b[0m\u001b[0mmessages::IpcResponse, \u001b[0m\u001b[0m\u001b[1mfailure::Error>\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m              found enum `messages::IpcResponse`\u001b[0m\n\n"}
-{"message":"aborting due to previous error; 12 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to previous error; 12 warnings emitted\u001b[0m\n\n"}
-{"message":"For more information about this error, try `rustc --explain E0308`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0308`.\u001b[0m\n"}
+{"message":"attribute should be applied to a free function, impl method or static","code":{"code":"unused_attributes","explanation":null},"level":"warning","spans":[{"file_name":"src/esgx/equote.rs","byte_start":134,"byte_end":1083,"line_start":12,"line_end":26,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"extern \"C\" {","highlight_start":1,"highlight_end":13},{"text":"    pub fn ecall_get_signing_address(eid: sgx_enclave_id_t, arr: *mut [u8; 20usize]) -> sgx_status_t;","highlight_start":1,"highlight_end":102},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn ecall_get_registration_quote(eid: sgx_enclave_id_t, retval: *mut sgx_status_t,","highlight_start":1,"highlight_end":90},{"text":"                                        target_info: *const sgx_target_info_t, report: *mut sgx_report_t) -> sgx_status_t;","highlight_start":1,"highlight_end":123},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn sgx_init_quote(p_target_info: *mut sgx_target_info_t, p_gid: *mut sgx_epid_group_id_t) -> sgx_status_t;","highlight_start":1,"highlight_end":115},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn sgx_calc_quote_size(p_sig_rl: *const uint8_t, sig_rl_size: uint32_t, p_quote_size: *mut uint32_t) -> sgx_status_t;","highlight_start":1,"highlight_end":126},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn sgx_get_quote(p_report: *const sgx_report_t, quote_type: sgx_quote_sign_type_t,","highlight_start":1,"highlight_end":91},{"text":"                         p_spid: *const sgx_spid_t, p_nonce: *const sgx_quote_nonce_t, p_sig_rl: *const uint8_t,","highlight_start":1,"highlight_end":113},{"text":"                         sig_rl_size: uint32_t, p_qe_report: *mut sgx_report_t, p_quote: *mut sgx_quote_t,","highlight_start":1,"highlight_end":107},{"text":"                         quote_size: uint32_t) -> sgx_status_t;","highlight_start":1,"highlight_end":64},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"not a free function, impl method or static","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/esgx/equote.rs","byte_start":121,"byte_end":133,"line_start":11,"line_end":11,"column_start":1,"column_end":13,"is_primary":true,"text":[{"text":"#[no_mangle]","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_attributes)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!","code":null,"level":"warning","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: attribute should be applied to a free function, impl method or static\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/esgx/equote.rs:11:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m#[no_mangle]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mextern \"C\" {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn ecall_get_signing_address(eid: sgx_enclave_id_t, arr: *mut [u8; 20usize]) -> sgx_status_t;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn ecall_get_registration_quote(eid: sgx_enclave_id_t, retval: *mut sgx_status_t,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                         quote_size: uint32_t) -> sgx_status_t;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m26\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mnot a free function, impl method or static\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_attributes)]` on by default\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\u001b[0m\n\n"}
+{"message":"`#[macro_use]` only has an effect on `extern crate` and modules","code":{"code":"unused_attributes","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":2253,"byte_end":2265,"line_start":57,"line_end":57,"column_start":5,"column_end":17,"is_primary":true,"text":[{"text":"    #[macro_use]  use failure::Error;","highlight_start":5,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: `#[macro_use]` only has an effect on `extern crate` and modules\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:57:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    #[macro_use]  use failure::Error;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\n\n"}
+{"message":"unused variable: `status`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":7348,"byte_end":7354,"line_start":200,"line_end":200,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"        let status = unsafe {","highlight_start":13,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":7348,"byte_end":7354,"line_start":200,"line_end":200,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"        let status = unsafe {","highlight_start":13,"highlight_end":19}],"label":null,"suggested_replacement":"_status","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `status`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:200:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m200\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let status = unsafe {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_status`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_variables)]` on by default\u001b[0m\n\n"}
+{"message":"unused variable: `data_size`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":7718,"byte_end":7727,"line_start":212,"line_end":212,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"        let data_size = unsafe { *size_ptr };","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":7718,"byte_end":7727,"line_start":212,"line_end":212,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"        let data_size = unsafe { *size_ptr };","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":"_data_size","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `data_size`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:212:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let data_size = unsafe { *size_ptr };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_data_size`\u001b[0m\n\n"}
+{"message":"unused variable: `status`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":8648,"byte_end":8654,"line_start":237,"line_end":237,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"        let status = unsafe {","highlight_start":13,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":8648,"byte_end":8654,"line_start":237,"line_end":237,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"        let status = unsafe {","highlight_start":13,"highlight_end":19}],"label":null,"suggested_replacement":"_status","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `status`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:237:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m237\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let status = unsafe {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_status`\u001b[0m\n\n"}
+{"message":"unused variable: `data_size`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":9016,"byte_end":9025,"line_start":249,"line_end":249,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"        let data_size = unsafe { *size_ptr };","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":9016,"byte_end":9025,"line_start":249,"line_end":249,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"        let data_size = unsafe { *size_ptr };","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":"_data_size","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `data_size`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:249:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m249\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let data_size = unsafe { *size_ptr };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_data_size`\u001b[0m\n\n"}
+{"message":"unused variable: `status`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":11980,"byte_end":11986,"line_start":326,"line_end":326,"column_start":14,"column_end":20,"is_primary":true,"text":[{"text":"         let status = unsafe {","highlight_start":14,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":11980,"byte_end":11986,"line_start":326,"line_end":326,"column_start":14,"column_end":20,"is_primary":true,"text":[{"text":"         let status = unsafe {","highlight_start":14,"highlight_end":20}],"label":null,"suggested_replacement":"_status","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `status`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:326:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m326\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         let status = unsafe {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_status`\u001b[0m\n\n"}
+{"message":"unused variable: `hm_size`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":12361,"byte_end":12368,"line_start":338,"line_end":338,"column_start":14,"column_end":21,"is_primary":true,"text":[{"text":"         let hm_size = unsafe { *size_ptr };","highlight_start":14,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":12361,"byte_end":12368,"line_start":338,"line_end":338,"column_start":14,"column_end":21,"is_primary":true,"text":[{"text":"         let hm_size = unsafe { *size_ptr };","highlight_start":14,"highlight_end":21}],"label":null,"suggested_replacement":"_hm_size","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `hm_size`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:338:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m338\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         let hm_size = unsafe { *size_ptr };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_hm_size`\u001b[0m\n\n"}
+{"message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":7265,"byte_end":7277,"line_start":198,"line_end":198,"column_start":13,"column_end":25,"is_primary":true,"text":[{"text":"        let mut size_ptr: *mut usize = &mut size;","highlight_start":13,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_mut)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":7265,"byte_end":7269,"line_start":198,"line_end":198,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut size_ptr: *mut usize = &mut size;","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:198:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m198\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut size_ptr: *mut usize = &mut size;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_mut)]` on by default\u001b[0m\n\n"}
+{"message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":8564,"byte_end":8576,"line_start":234,"line_end":234,"column_start":13,"column_end":25,"is_primary":true,"text":[{"text":"        let mut size_ptr: *mut usize = &mut size;","highlight_start":13,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":8564,"byte_end":8568,"line_start":234,"line_end":234,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut size_ptr: *mut usize = &mut size;","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:234:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m234\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut size_ptr: *mut usize = &mut size;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\n"}
+{"message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":11895,"byte_end":11907,"line_start":323,"line_end":323,"column_start":13,"column_end":25,"is_primary":true,"text":[{"text":"        let mut size_ptr: *mut usize = &mut size;","highlight_start":13,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"src/networking/ipc_listener.rs","byte_start":11895,"byte_end":11899,"line_start":323,"line_end":323,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut size_ptr: *mut usize = &mut size;","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/networking/ipc_listener.rs:323:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m323\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut size_ptr: *mut usize = &mut size;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\n"}
+{"message":"17 warnings emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: 17 warnings emitted\u001b[0m\n\n"}
Index: enclave/app/target/release/.fingerprint/heatmap-app-e5c4786377f516fd/run-build-script-build-script-build.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/app/target/release/.fingerprint/heatmap-app-e5c4786377f516fd/run-build-script-build-script-build.json b/enclave/app/target/release/.fingerprint/heatmap-app-e5c4786377f516fd/run-build-script-build-script-build.json
--- a/enclave/app/target/release/.fingerprint/heatmap-app-e5c4786377f516fd/run-build-script-build-script-build.json	
+++ b/enclave/app/target/release/.fingerprint/heatmap-app-e5c4786377f516fd/run-build-script-build-script-build.json	(date 1664077233334)
@@ -1,1 +1,1 @@
-{"rustc":16864309158671632917,"features":"","target":0,"profile":0,"path":0,"deps":[[933630640346235945,"build_script_build",false,14389605580895843363],[1175692184310149643,"build_script_main",false,9569703133079617126]],"local":[{"Precalculated":"1663684879.427375779s (Cargo.lock)"}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
\ No newline at end of file
+{"rustc":16864309158671632917,"features":"","target":0,"profile":0,"path":0,"deps":[[933630640346235945,"build_script_build",false,14389605580895843363],[1175692184310149643,"build_script_main",false,15645271175513290186]],"local":[{"Precalculated":"1664077232.866061661s (Cargo.lock)"}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
\ No newline at end of file
Index: enclave/app/Cargo.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/app/Cargo.toml b/enclave/app/Cargo.toml
--- a/enclave/app/Cargo.toml	
+++ b/enclave/app/Cargo.toml	(date 1664075527687)
@@ -7,10 +7,6 @@
 [dependencies]
 sgx_types = { git = "https://github.com/apache/teaclave-sgx-sdk.git" }
 sgx_urts = { git = "https://github.com/apache/teaclave-sgx-sdk.git" }
-#enigma-types = { git = "https://github.com/njeans/enigma-core.git", branch="nerla", features = ["std"] }
-#enigma-tools-u = { git = "https://github.com/njeans/enigma-core.git", branch="nerla" }
-#enigma-tools-m = { git = "https://github.com/njeans/enigma-core.git", branch="nerla" }
-#enigma-crypto = { git = "https://github.com/njeans/enigma-core.git", branch="nerla" }
 
 futures = { version = "0.1.25", default-features = false }
 tokio-zmq = "0.9.0"
@@ -86,12 +82,6 @@
 sgx_unwind = { path = "../../../incubator-teaclave-sgx-sdk-master/sgx_unwind" }
 sgx_urts = { path = "../../../incubator-teaclave-sgx-sdk-master/sgx_urts" }
 
-# [patch.'https://github.com/njeans/enigma-core.git']
-# enigma-types = { path = "../../../enigma-core/enigma-types" }
-# enigma-crypto = { path = "../../../enigma-core/enigma-crypto" }
-# enigma-tools-u = { path = "../../../enigma-core/enigma-tools-u" }
-# enigma-tools-m = { path = "../../../enigma-core/enigma-tools-m" }
-
 [patch.'https://github.com/mesalock-linux/serde-sgx.git']
 serde = {git = "https://github.com/njeans/serde-sgx.git"}
 serde_derive = {git = "https://github.com/njeans/serde-sgx.git"}
Index: enclave/enclave/src/crypto/hash.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/enclave/src/crypto/hash.rs b/enclave/enclave/src/crypto/hash.rs
--- a/enclave/enclave/src/crypto/hash.rs	
+++ b/enclave/enclave/src/crypto/hash.rs	(date 1663992594863)
@@ -5,14 +5,12 @@
 use std::string::String;
 use std::vec::Vec;
 use core::ops::{Deref, DerefMut};
+use hex::{FromHex, FromHexError};
 
 use tiny_keccak::Keccak;
 use sha2;
-// use rustc_hex::{FromHex, FromHexError};
-
-use hex::{FromHex, FromHexError};
 use arrayvec::ArrayVec;
-use crate::serde::{Serialize, Deserialize};
+use serde::{Serialize, Deserialize};
 
 /// This struct is basically a wrapper over `[u8; 32]`, and is meant to be returned from whatever hashing functions we use.
 /// `#[repr(C)]` is a Rust feature which makes the struct be aligned just like C structs.
@@ -152,17 +150,13 @@
 }
 
 
-impl Keccak256<Hash256> for String {
+impl Keccak256<Hash256> for String {//for hex public key
     fn keccak256(&self) -> Hash256 {
         let mut keccak = Keccak::new_keccak256();
         let mut result = Hash256::default();
         let val: Vec<u8> = self.from_hex().unwrap();
-        // let val = <Vec<u8>>::from_hex("48656c6c6f20776f726c6421");
-
-        println!("keccak256_self={:?}",&val);
         keccak.update(&val);
         keccak.finalize(result.as_mut());
-        println!("keccak256_result={:?}",&result);
         result
     }
 }
Index: enclave/enclave/src/crypto/asymmetric.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/enclave/src/crypto/asymmetric.rs b/enclave/enclave/src/crypto/asymmetric.rs
--- a/enclave/enclave/src/crypto/asymmetric.rs	
+++ b/enclave/enclave/src/crypto/asymmetric.rs	(date 1664008252218)
@@ -8,6 +8,8 @@
 //! After this PR I think it would be possible to swap that library in instead of the current one.
 //!
 //! Here is a PoC of how it can be done easily (and the one problem with it) https://github.com/enigmampc/enigma-core/pull/167
+use std::str;
+
 use sha2;
 use libsecp256k1;
 use libsecp256k1::{PublicKey, SecretKey, SharedSecret,  RecoveryId, Signature};
@@ -113,13 +115,17 @@
         self.sign_hashed(&message.keccak256().into())
     }
 
+    pub fn sign_eth(&self, message: &[u8]) -> Result<[u8; 65], CryptoError> {
+        let encode_defunct = format!("\x19Ethereum Signed Message:\n{}{}",message.len(),str::from_utf8(message).unwrap());
+        self.sign_hashed(&encode_defunct.as_bytes().keccak256().into())
+    }
+
     /// Interface for usage without forcing a keccak hash of the input. However, the input must be 32 bytes long.
     /// Mainly useful for when the data is created already hashed and we just want to sign it
     pub fn sign_hashed(&self, message: &[u8; 32]) -> Result<[u8; 65], CryptoError> {
         let message_to_sign = libsecp256k1::Message::parse(message);
-
         let (sig, recovery) = libsecp256k1::sign(&message_to_sign, &self.privkey);
-        // .map_err(|_| CryptoError::SigningError { hashed_msg: *message })?;
+        //.map_err(|_| CryptoError::SigningError { hashed_msg: *message })?;
 
         let v: u8 = recovery.into();
         let mut returnvalue = [0u8; 65];
Index: enclave/enclave/src/lib.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/enclave/src/lib.rs b/enclave/enclave/src/lib.rs
--- a/enclave/enclave/src/lib.rs	
+++ b/enclave/enclave/src/lib.rs	(date 1664076391987)
@@ -22,41 +22,27 @@
 #![cfg_attr(not(target_env = "sgx"), no_std)]
 #![cfg_attr(target_env = "sgx", feature(rustc_private))]
 
-extern crate sgx_types;
 #[cfg(not(target_env = "sgx"))]
 #[macro_use]
 extern crate sgx_tstd as std;
 
+extern crate sgx_types;
 extern crate sgx_rand;
-// extern crate sgx_trts;
 extern crate sgx_tseal;
+
 #[macro_use]
 extern crate lazy_static;
 
 extern crate serde;
-// #[macro_use]
 extern crate serde_json;
-extern crate rustc_hex as hex;
+extern crate rand_hc;
+extern crate rand_core;
+extern crate aligned_cmov;
 
 extern crate mc_oblivious_ram;
 extern crate mc_oblivious_traits;
-extern crate rand_hc;
-extern crate rand_core;
 extern crate mc_fog_ocall_oram_storage_trusted;
-extern crate aligned_cmov;
-
-// extern crate sgx_serialize;
-// #[macro_use]
-// extern crate sgx_serialize_derive;
-
-
-// extern crate serde;
-// extern crate secp256k1;
-// extern crate tiny_keccak;
-// extern crate sha2;
-// extern crate rustc_hex;
-// extern crate arrayvec;
-// extern crate ring;
+extern crate rustc_hex as hex;
 
 mod user_db;
 mod heatmap;
@@ -69,12 +55,8 @@
 use std::{slice};
 use std::path::{Path, PathBuf};
 use std::string::{String, ToString};
-//     vec::Vec,
-//     str,
-//     collections::HashMap,
-//     cmp
-// };
 
+use sgx_tse::rsgx_create_report;
 use sgx_types::{
     sgx_status_t,
     sgx_report_t,
@@ -82,31 +64,14 @@
     sgx_report_data_t
 };
 
-use sgx_tse::rsgx_create_report;
-
 
 use user_db::{init_user_db, load_user_db, get_enclave_data};
 use heatmap::{add_personal_data_internal, retrieve_heatmap_oram, reset_heatmap, get_audit_data};
 use crypto::asymmetric;
-use types::{EnclaveReturn, PubKey, DhKey, EnclaveError, EnclaveSystemError, CryptoError};
+use types::{EnclaveReturn, EnclaveError, EnclaveErrorType::{CryptoErrorType, SgxError}, CryptoError};
+use types::{PubKey, DhKey};
 use traits::{EthereumAddress, SliceCPtr};
 
-// use storage::*;
-// use enigma_types::{PubKey, DhKey, EnclaveReturn};
-// use enigma_tools_t::{
-//     common::errors_t::{EnclaveError},
-//     storage_t,
-//     quote_t,
-// };
-// use enigma_tools_m::utils::EthereumAddress;
-//
-// use enigma_tools_m::utils::{LockExpectMutex};
-// use enigma_crypto::{asymmetric, CryptoError};
-
-// mod multipart_datas;
-// use traits::SliceCPtr;
-
-// use enigma_tools_t::{esgx::ocalls_t};
 
 lazy_static! {
     pub(crate) static ref SIGNING_KEY: asymmetric::KeyPair = get_sealed_keys_wrapper("sign".to_string());
@@ -125,7 +90,10 @@
 pub extern "C" fn ecall_get_encryption_pubkey(sig: &mut [u8; 65], pubkey: &mut [u8; 64]) -> EnclaveReturn {
     let signature = match SIGNING_KEY.sign(&ENCRYPT_KEY.get_pubkey()) {
         Ok(x) => x,
-        Err(e) => return e.into(),
+        Err(e) => {
+            println!("ecall_get_encryption_pubkey SIGNING_KEY.sign err {:?}", e);
+            return e.into();
+        },
     };
     sig.copy_from_slice(&signature);
     pubkey.copy_from_slice(&ENCRYPT_KEY.get_pubkey());
@@ -136,12 +104,12 @@
 #[no_mangle]
 extern "C" {
     fn ocall_save_to_memory(ptr: *mut u64, data_ptr: *const u8, data_len: usize) -> sgx_status_t;
-    fn allocate_oram_storage(count: u64, data_size: u64, meta_size: u64, id_out: *mut u64);// -> sgx_status_t;
-    fn release_oram_storage(id: u64);// -> sgx_status_t;
+    fn allocate_oram_storage(count: u64, data_size: u64, meta_size: u64, id_out: *mut u64) -> sgx_status_t;
+    fn release_oram_storage(id: u64) -> sgx_status_t;
     fn checkout_oram_storage( id: u64, idx: *const u64, idx_len: usize, databuf: *mut u64,
-        databuf_len: usize, metabuf: *mut u64, metabuf_len: usize);// -> sgx_status_t;
+        databuf_len: usize, metabuf: *mut u64, metabuf_len: usize) -> sgx_status_t;
     fn checkin_oram_storage( id: u64, idx: *const u64, idx_len: usize, databuf: *const u64,
-                                databuf_len: usize, metabuf: *const u64, metabuf_len: usize);// -> sgx_status_t;
+                                databuf_len: usize, metabuf: *const u64, metabuf_len: usize) -> sgx_status_t;
 }
 
 fn get_sealed_keys_wrapper(name: String) -> asymmetric::KeyPair {
@@ -169,7 +137,10 @@
         println!("ecall_init_user_db load_user_db");
         return match load_user_db() {
             Ok(_) => EnclaveReturn::Success,
-            Err(e) => e.into()
+            Err(e) => {
+                println!("ecall_init_user_db load_user_db err {:?}", e);
+                e.into()
+            }
         };
     }
 
@@ -178,13 +149,19 @@
 
     let user_info = match init_user_db(database) {
         Ok(x) => x,
-        Err(e) => return e.into(),
+        Err(e) =>  {
+            println!("ecall_init_user_db init_user_db(database) err {:?}", e);
+            return e.into();
+        },
     };
     println!("ecall_init_user_db user_info {:?}",user_info);
 
     match heatmap::reset_heatmap(){
         Ok(_) => {},
-        Err(e) => return e.into(),
+        Err(e) => {
+            println!("ecall_init_user_db heatmap::reset_heatmap() err {:?}", e);
+            return e.into();
+        },
     };
 
     EnclaveReturn::Success
@@ -194,16 +171,14 @@
     let user_keys = match user_db::USER_KEYS.read() {
         Ok(x)=>x,
         Err(e)=>{
-            println!("get_io_key.read() {:?}",e);
-            return Err(EnclaveError::SystemError(EnclaveSystemError::CryptoError{err: CryptoError::MissingKeyError{ key_type: "DH Key"}}));
+            return Err(EnclaveError{trace:"lib.get_io_key  user_db::USER_KEYS.read()".to_string(), err:SgxError{description:e.to_string()}});
 
         }
     };
     let (pubkey, io_key) = match user_keys.get(&userid) {
         Some(x) => x,
         None => {
-            println!("get_io_key.get() not found {:?}",userid);
-            return Err(EnclaveError::SystemError(EnclaveSystemError::CryptoError{err: CryptoError::MissingKeyError{ key_type: "DH Key"}}));
+            return Err(EnclaveError{trace:"lib.get_io_key  user_db::USER_KEYS.read()".to_string(), err:CryptoErrorType{err:CryptoError::MissingKeyError{ key_type: "DH Key"}}});
         }
     };
     Ok((pubkey.clone(),*io_key))
@@ -218,12 +193,12 @@
     println!("ecall_add_personal_data");
 
     if user_id_len != 5 {
-        println!("wrong user_id_len {:?}",user_id_len);
-        return EnclaveError::SystemError(EnclaveSystemError::SgxError{ err: "user_id_len user_id_len".to_string(), description:"user_id_len".to_string()}).into();
+        println!("ecall_add_personal_data wrong user_id_len {:?}",user_id_len);
+        return EnclaveReturn::InputError;
     }
     let userid = slice::from_raw_parts(user_id_ptr, user_id_len);
     let encrypted_data = slice::from_raw_parts(encrypted_data_ptr, encrypted_data_len);
-    println!("ecall_add_personal_data userid {:?} encrypted_data {:?}", userid, encrypted_data);
+    println!("ecall_add_personal_data userid {:?}", userid);
 
     let mut uid = [0;5];
     uid.copy_from_slice(&userid[0..5]);
@@ -257,23 +232,35 @@
     let empty = [0u8];
     *serialized_ptr = match save_to_untrusted_memory(&empty) {
         Ok(ptr) => ptr,
-        Err(e) => return e.into(),
+        Err(e) => {
+            println!("ecall_retrieve_heatmap save_to_untrusted_memory err {:?}", e);
+            return e.into();
+        },
     };
 
     let heatmap = match retrieve_heatmap_oram() {
         Ok(x) => x,
-        Err(e) => return e.into(),
+        Err(e) => {
+            println!("ecall_retrieve_heatmap load_user_db err {:?}", e);
+            return e.into();
+        },
     };
     let heatmap_len = heatmap.len();
     unsafe { std::ptr::copy( &heatmap_len, out_ptr_size, 1) }
     *serialized_ptr = match save_to_untrusted_memory(&heatmap[..]) {
         Ok(ptr) => ptr,
-        Err(e) => return e.into(),
+        Err(e) => {
+            println!("ecall_retrieve_heatmap save_to_untrusted_memory err {:?}", e);
+            return e.into();
+        },
     };
 
     let signature = match ENCRYPT_KEY.sign(&heatmap) {
         Ok(x) => x,
-        Err(e) => return e.into(),
+        Err(e) => {
+            println!("ecall_retrieve_heatmap ENCRYPT_KEY.sign(&heatmap) err {:?}", e);
+            return e.into();
+        },
     };
     sig.copy_from_slice(&signature);
 
@@ -292,13 +279,16 @@
     let empty = [0u8];
     *serialized_ptr = match save_to_untrusted_memory(&empty) {
         Ok(ptr) => ptr,
-        Err(e) => return e.into(),
+        Err(e) => {
+            println!("ecall_get_enclave_data save_to_untrusted_memory err {:?}", e);
+            return e.into();
+        },
     };
 
     let data = match get_enclave_data() {
         Ok(x) => x,
         Err(e) => {
-            println!("ecall_get_enclave_data get_enclave_data err {:?}",e);
+            println!("ecall_get_enclave_data get_enclave_data() err {:?}",e);
             return e.into()
         }
     };
@@ -313,14 +303,16 @@
         }
     };
     println!("ecall_get_enclave_data signing {:?}", data);
-    let signature = match ENCRYPT_KEY.sign(&data) {
+    let signature = match ENCRYPT_KEY.sign_eth(&data) {
         Ok(x) => x,
         Err(e) => {
-            println!("ecall_get_enclave_data sign err {:?}",e);
+            println!("ecall_get_enclave_data ENCRYPT_KEY.sign(&data) err {:?}",e);
             return e.into()
         }
     };
     sig.copy_from_slice(&signature);
+    println!("signature={:?}",&signature);
+    println!("ecall_get_enclave_data signature {:?}", &signature);
 
     EnclaveReturn::Success
 }
@@ -336,13 +328,16 @@
     let empty = [0u8];
     *serialized_ptr = match save_to_untrusted_memory(&empty) {
         Ok(ptr) => ptr,
-        Err(e) => return e.into(),
+        Err(e) => {
+            println!("ecall_get_audit_data save_to_untrusted_memory err {:?}", e);
+            return e.into();
+        },
     };
 
     let data = match get_audit_data() {
         Ok(x) => x,
         Err(e) => {
-            println!("ecall_get_audit_data get_audit_data err {:?}",e);
+            println!("ecall_get_audit_data get_audit_data() err {:?}",e);
             return e.into()
         }
     };
@@ -366,13 +361,13 @@
     };
     sig.copy_from_slice(&signature);
 
-    match heatmap::reset_heatmap(){
-        Ok(_) => {},
-        Err(e) => {
-            println!("ecall_get_audit_data reset_heatmap err {:?}",e);
-            return e.into()
-        }
-    };
+    // match heatmap::reset_heatmap(){ todo uncomment
+    //     Ok(_) => {},
+    //     Err(e) => {
+    //         println!("ecall_get_audit_data reset_heatmap err {:?}",e);
+    //         return e.into()
+    //     }
+    // };
 
     EnclaveReturn::Success
 }
@@ -390,10 +385,9 @@
         }
         Err(r) => {
             println!("[-] Enclave: error creating report");
-            r
-        }
-    };
-    sgx_status_t::SGX_SUCCESS
+            sgx_status_t::SGX_SUCCESS
+        }
+    }
 }
 
 pub fn save_to_untrusted_memory(data: &[u8]) -> Result<u64, EnclaveError> {
Index: enclave/enclave/src/types.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/enclave/src/types.rs b/enclave/enclave/src/types.rs
--- a/enclave/enclave/src/types.rs	
+++ b/enclave/enclave/src/types.rs	(date 1663986394455)
@@ -11,81 +11,87 @@
 #[derive(Debug, Clone, Copy, PartialEq)]
 pub enum EnclaveReturn {
     Success,
-    TaskFailure,
     KeysError,
     EncryptionError,
     SigningError,
     PermissionError,
     SgxError,
-    StateError,
-    OcallError,
-    OcallDBError,
-    MessagingError,
-    Other,
-//    Uninitialized,
+    InputError,
+    UnsealError,
+    // StateError,
+    // OcallError,
+    // OcallDBError,
+    // MessagingError,
+    // Uninitialized,
 }
 
 #[derive(Debug, Clone)]
-pub enum EnclaveError {
-    SystemError(EnclaveSystemError),
-    BadUserId,
-    UnsealError
+pub struct  EnclaveError {
+    pub trace: String,
+    pub err: EnclaveErrorType,
+}
+
+#[derive(Debug, Clone)]
+pub enum EnclaveErrorType {
+    InvalidInput { description: String },
+    SgxError { description: String },
+    UnsealError,
+    CryptoErrorType{ err: CryptoError},
+    PermissionError{file: String}
 }
 
 impl ::std::fmt::Display for EnclaveError {
     fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::result::Result<(), ::std::fmt::Error> {
-        match self {
-            EnclaveError::BadUserId => write!(f, "bad user id"),
-            EnclaveError::UnsealError => write!(f, "unseal error"),
-            EnclaveError::SystemError(ref e) => write!(f, "{:?}", e),
+        match self.err {
+            EnclaveErrorType::SgxError{ .. } => write!(f, "SgxError"),
+            EnclaveErrorType::CryptoErrorType{ .. } => write!(f, "CryptoError"),
+            EnclaveErrorType::InvalidInput{ .. } => write!(f, "InvalidInput"),
+            EnclaveErrorType::UnsealError => write!(f, "UnsealError"),
+            EnclaveErrorType::PermissionError{ .. } => write!(f, "PermissionError"),
         }
     }
 }
 
-#[derive(Debug, Clone)]
-pub enum EnclaveSystemError {
-    // #[fail(display = "Cryptography Error: {:?}", err)]
-    CryptoError { err: CryptoError },
+impl From<sgx_status_t> for EnclaveError {
+    fn from(err: sgx_status_t) -> EnclaveError {
+        EnclaveError{ trace: err.as_str().to_string(), err:EnclaveErrorType::SgxError{description: err.__description().to_string() }}
+    }
+}
 
-    //    #[fail(display = "There's no sufficient permissions to read this file: {}", file)]
-    PermissionError { file: String },
-
-    //    #[fail(display = "An SGX Error has occurred: {}, Description: {}", err, description)]
-    SgxError { err: String, description: String },
-
-    //    #[fail(display = "There's a State error with: {}", err)]
-    // StateError { err: String },
-
-    //    #[fail(display = "There's an error with the ocall: {}; {}", command, err)]
-    // OcallError { command: String, err: String },
-
-    //    #[fail(display = "There's an error with the messaging: {}", err)]
-    // MessagingError { err: String },
-
-    // #[fail(display = "Failed to authenticate the worker: {}", err)]
-    // WorkerAuthError { err: String },
-
-    // #[fail(display = "Failed to provide state key: {}", err)]
-    // KeyProvisionError { err: String },
-}
 
 impl From<CryptoError> for EnclaveError {
     fn from(err: CryptoError) -> EnclaveError {
-        EnclaveError::SystemError(EnclaveSystemError::CryptoError { err })
+        EnclaveError{ trace: "".to_string(), err: EnclaveErrorType::CryptoErrorType{err}}
     }
 }
 
-impl From<CryptoError> for EnclaveReturn {
-    fn from(err: CryptoError) -> EnclaveReturn {
-        EnclaveError::SystemError(EnclaveSystemError::CryptoError { err }).into()
+
+impl Into<EnclaveReturn> for EnclaveError {
+    fn into(self) -> EnclaveReturn {
+        use self::EnclaveErrorType::*;
+        use self::CryptoError::*;
+        match self.err {
+            CryptoErrorType{err} => err.into(),
+            SgxError { .. } => EnclaveReturn::SgxError,
+            InvalidInput { .. } => EnclaveReturn::InputError,
+            UnsealError  => EnclaveReturn::UnsealError,
+            EnclaveErrorType::PermissionError { .. } => EnclaveReturn::PermissionError,
+        }
     }
 }
 
-impl From<sgx_status_t> for EnclaveError {
-    fn from(err: sgx_status_t) -> EnclaveError {
-        EnclaveError::SystemError(EnclaveSystemError::SgxError { err: err.as_str().to_string(), description: err.__description().to_string() })
+impl Into<EnclaveReturn> for CryptoError {
+    fn into(self) -> EnclaveReturn {
+        use self::CryptoError::*;
+        match self {
+                RandomError { .. } => EnclaveReturn::SgxError,
+                DerivingKeyError { .. } | KeyError { .. } | MissingKeyError { .. } => EnclaveReturn::KeysError,
+                DecryptionError { .. } | EncryptionError { .. } | SigningError { .. } | ImproperEncryption |
+                ParsingError { .. } | RecoveryError { .. } => EnclaveReturn::EncryptionError,
+        }
     }
 }
+
 
 #[derive(Clone)]
 pub enum CryptoError {
@@ -180,33 +186,4 @@
             },
         }
     }
-}
-
-
-impl Into<EnclaveReturn> for EnclaveError {
-    fn into(self) -> EnclaveReturn {
-        use self::EnclaveError::*;
-        use self::EnclaveSystemError::*;
-        use self::CryptoError::*;
-        match self {
-            SystemError(e) => {
-                match e {
-                    PermissionError { .. } => EnclaveReturn::PermissionError,
-                    SgxError { .. } => EnclaveReturn::SgxError,
-                    // EnclaveSystemError::StateError { .. } => EnclaveReturn::StateError,
-                    // EnclaveSystemError::OcallError { .. } => EnclaveReturn::OcallError,
-                    // EnclaveSystemError::MessagingError { .. } => EnclaveReturn::MessagingError,
-                    CryptoError{err} => match err {
-                        RandomError { .. } => EnclaveReturn::SgxError,
-                        DerivingKeyError { .. } | KeyError { .. } | MissingKeyError { .. } => EnclaveReturn::KeysError,
-                        DecryptionError { .. } | EncryptionError { .. } | SigningError { .. } | ImproperEncryption |
-                        ParsingError { .. } | RecoveryError { .. } => EnclaveReturn::EncryptionError,
-                    }
-                }
-
-            },
-            BadUserId=>EnclaveReturn::TaskFailure,
-            UnsealError=>EnclaveReturn::TaskFailure
-        }
-    }
 }
\ No newline at end of file
Index: enclave/enclave/src/traits.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/enclave/src/traits.rs b/enclave/enclave/src/traits.rs
--- a/enclave/enclave/src/traits.rs	
+++ b/enclave/enclave/src/traits.rs	(date 1663999803936)
@@ -2,7 +2,7 @@
 use std::string::{String,ToString};
 use std::str;
 
-use rustc_hex::ToHex;
+use hex::ToHex;
 
 use crate::crypto::hash::Keccak256;
 
@@ -45,29 +45,19 @@
 
 
 impl EthereumAddress<String, [u8; 20]> for String {
-    // TODO: Maybe add a checksum address
     fn address_string(&self) -> String {
         let hex: String = self.keccak256()[12..32].to_hex();
         let address = hex.trim_start_matches("0x").to_lowercase();
-        // let address = "e0fc04fa2d34a66b779fd5cee748268032a146c0".to_string();
-        println!("address {:?}",address);
         let address_hash:String = address.as_bytes().keccak256().to_hex();
-        println!("address_hash {:?}",address_hash);
         address
             .char_indices()
             .fold(String::from("0x"), |mut acc, (index, address_char)| {
-                // this cannot fail since it's Keccak256 hashed
                 let n = u16::from_str_radix(&address_hash[index..index + 1], 16).unwrap();
-                println!("to_uppercase index {:?} n: {:?} {:?}",index, n, &address_char.to_uppercase());
-
-                if n > 7 {
-                    // make char uppercase if ith character is 9..f
-                    println!("to_uppercase index {:?} n: {:?} {:?}",index, n, &address_char.to_uppercase());
-                    acc.push_str(&address_char.to_uppercase().to_string())
-                } else {
-                    // already lowercased
-                    acc.push(address_char)
-                }
+                // if n > 7 {
+                //     acc.push_str(&address_char.to_uppercase().to_string())
+                // } else {
+                    acc.push(address_char);
+                // }
                 acc
             })
 
Index: enclave/enclave/src/heatmap.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/enclave/src/heatmap.rs b/enclave/enclave/src/heatmap.rs
--- a/enclave/enclave/src/heatmap.rs	
+++ b/enclave/enclave/src/heatmap.rs	(date 1664072622677)
@@ -3,6 +3,7 @@
 use std::collections::HashMap;
 use std::borrow::ToOwned;
 
+
 use serde::{Deserialize, Serialize};
 use serde_json::{Value, json};
 use aligned_cmov::{A64Bytes, ArrayLength};
@@ -15,7 +16,7 @@
 use mc_fog_ocall_oram_storage_trusted::OcallORAMStorageCreator;
 
 use crate::types::{PubKey, DhKey};
-use crate::types::{EnclaveError::{self, SystemError}, EnclaveSystemError::{CryptoError as CryptoErrorType, SgxError}, CryptoError};
+use crate::types::{EnclaveError, EnclaveErrorType::{SgxError, CryptoErrorType, InvalidInput}, CryptoError};
 use crate::traits::EthereumAddress;
 use crate::crypto::symmetric::decrypt;
 use crate::multipart_data::MultipartDatabase;
@@ -23,15 +24,15 @@
 pub const USER_DATA_NAME: &str = "data";
 pub const AUDIT_DATA_NAME: &str = "audit";
 
-pub const MAX_DATA_SIZE: usize = 36;       // Manually calculated max
-pub const MAX_AUDIT_DATA_SIZE: usize = 36;       // Manually calculated max
+pub const MAX_DATA_SIZE: usize = 13;       // Manually calculated max dependent on SEAL_LOG_SIZE
+pub const MAX_AUDIT_DATA_SIZE: usize = 36;       // Manually calculated max dependent on SEAL_LOG_SIZE
 
 //Beijing numbers
 pub const LONG_MIN: f64 = 116.0;
 pub const LONG_MAX: f64 = 116.75;
 pub const LAT_MIN: f64 = 39.5;
 pub const LAT_MAX: f64 = 40.25;
-pub const HEATMAP_GRANULARITY: u64 = 50;
+pub const HEATMAP_GRANULARITY: u64 = 5;//0;
 pub const HEATMAP_COUNT_THRESHOLD: u16 = 2;
 
 pub const TIMEFRAME_GRANULARITY: f64 = 10.0; // this is in minutes
@@ -48,26 +49,21 @@
 
 pub fn decrypt_data(data: &[u8], key: &DhKey) -> Result<Vec<u8>, EnclaveError> {
     if data.is_empty() {
-        Err(SystemError(CryptoErrorType{err: CryptoError::DecryptionError}))
+        Err(EnclaveError{trace: "heatmap.decrypt_data data.is_empty()".to_string(),err:CryptoErrorType{err:CryptoError::DecryptionError}})
     } else {
         Ok(decrypt(data, key)?)
     }
 }
 
-pub fn geo_time_index(geo_time: &GeolocationTime) -> Result<u64, String>{
-    println!("geo_time_index geo_time.lat {:?} geo_time.lng {:?}",geo_time.lat,geo_time.lng);
+pub fn geo_time_index(geo_time: &GeolocationTime) -> Result<u64, EnclaveError>{
     if geo_time.lat < LAT_MIN || geo_time.lat > LAT_MAX || geo_time.lng < LONG_MIN || geo_time.lng > LONG_MAX{
-        println!("geo_time_index LAT_MIN {:?} LAT_MAX {:?} LONG_MIN {:?}  LONG_MAX {:?} ",geo_time.lat < LAT_MIN,geo_time.lat > LAT_MAX,geo_time.lng < LONG_MIN,geo_time.lng > LONG_MAX);
-        return Err("invalid input".to_string())
+        let description = format!("geo_time is out of bounds lat {:?} lng {:?}",geo_time.lat,geo_time.lng);
+        return Err(EnclaveError{trace:"heatmap.geo_time_index if geo_time.lat < LAT_MIN || ...".to_string(), err:InvalidInput{description}});
     }
-    // r/50
-    // v-min
     let side_length_lat = HEATMAP_GRANULARITY as f64/(LAT_MAX- LAT_MIN);
     let side_length_long = HEATMAP_GRANULARITY as f64/(LONG_MAX- LONG_MIN);
     let lat: u64 = ((geo_time.lat - LAT_MIN)*side_length_lat).round() as u64;
     let lng: u64 = ((geo_time.lng - LONG_MIN)*side_length_long).round() as u64;
-    println!("geo_time_index side_length_lat {:?} side_length_long {:?}",side_length_lat,side_length_long);
-    println!("geo_time_index lat {:?} lng {:?}",lat,lng);
     Ok(lat*HEATMAP_GRANULARITY + lng)
 }
 
@@ -79,10 +75,24 @@
 
 pub fn reset_heatmap() -> Result<(), EnclaveError> {
     let data: Vec<GeolocationTime> = Vec::new();
-    MultipartDatabase::<GeolocationTime>::create(String::from(USER_DATA_NAME),MAX_DATA_SIZE, true, data).save()?;
+    match MultipartDatabase::<GeolocationTime>::create(String::from(USER_DATA_NAME),MAX_DATA_SIZE, true, data).save() {
+        Ok(_) => {}
+        Err(mut e) => {
+            let trace = format!("{} || heatmap.reset_heatmap MultipartDatabase::<GeolocationTime>::create(USER_DATA_NAME).save()",e.trace);
+            e.trace = trace;
+            return Err(e)
+        }
+    }
 
     let audit_data: Vec<String> = Vec::new();
-    MultipartDatabase::<String>::create(String::from(AUDIT_DATA_NAME), MAX_AUDIT_DATA_SIZE, true, audit_data).save()?;
+    match MultipartDatabase::<String>::create(String::from(AUDIT_DATA_NAME), MAX_AUDIT_DATA_SIZE, true, audit_data).save() {
+        Ok(_) => {}
+        Err(mut e) => {
+            let trace = format!("{} || heatmap.reset_heatmap MultipartDatabase::<GeolocationTime>::create(AUDIT_DATA_NAME).save()",e.trace);
+            e.trace = trace;
+            return Err(e)
+        }
+    }
 
     Ok(())
 }
@@ -90,52 +100,64 @@
 pub fn add_personal_data_internal(encrypted_data: &[u8], dhKey: &DhKey, publickey: String)  -> Result<(), EnclaveError> {
     let decrypted_data = match decrypt_data(encrypted_data, dhKey) {
         Ok(v) => v,
-        Err(e) => {
-            println!("decrypt_data e {:?}",e);
-            return Err(e)
+        Err(mut e) => {
+            let trace = format!("{} || heatmap.add_personal_data_internal decrypt_data(encrypted_data, dhKey)",e.trace);
+            e.trace = trace;
+            return Err(e);
         }
     };
 
     let mut audit_db = MultipartDatabase::<String>::load(String::from(AUDIT_DATA_NAME))?;
     let audit_data:Vec<String> = Vec::from([publickey]);
-    audit_db.append(audit_data)?;
+    match audit_db.append(audit_data) {
+        Ok(_) => {}
+        Err(mut e) => {
+            let trace = format!("{} || heatmap.add_personal_data_internal audit_db.append(audit_data)",e.trace);
+            e.trace = trace;
+            return Err(e)
+        }
+    };
     let input_data: Vec<GeolocationTime> = serde_json::from_slice(&decrypted_data).unwrap();
     let mut data_db = MultipartDatabase::<GeolocationTime>::load(String::from(USER_DATA_NAME))?;
-    data_db.append(input_data)?;
+    match data_db.append(input_data) {
+        Ok(_) => {}
+        Err(mut e) => {
+            let trace = format!("{} || heatmap.add_personal_data_internal data_db.append(input_data)",e.trace);
+            e.trace = trace;
+            return Err(e)
+        }
+    };
 
     Ok(())
 }
 
 pub fn retrieve_heatmap_oram() -> Result<Vec<u8>, EnclaveError> {
-    println!("Retrieving heatmap");
+    println!("heatmap.retrieve_heatmap_oram");
 
     let mut data_db = MultipartDatabase::<GeolocationTime>::load(String::from(USER_DATA_NAME))?;
-    println!("Retrieving data_db {:?}",data_db.len());
 
     let mut maker = rng_maker(get_seeded_rng());
     let oram_size = get_next_power_2(HEATMAP_GRANULARITY.pow(2));
-    println!("Retrieving oram_size {:?}",oram_size);
     let mut oram = PathORAM4096Z4Creator::<RngType, OcallORAMStorageCreator>::create(
         oram_size,
         STASH_SIZE,
         &mut maker,
     );
-    println!("Retrieving oram made");
 
     for i in 0..data_db.len(){
         let data = data_db.get(i)?;
-        println!("Retrieving data {:?}",data);
         for geo_time in data.iter(){
             let oram_index = match geo_time_index(geo_time) {
                 Ok(v) => v,
-                Err(err) => {
-                    println!("geo_time_index err {:?}",err);
-                    return Err(SystemError(SgxError{ err: err.to_string(), description:"geo_time_index".to_string()}));
+                Err(mut e) => {
+                    let trace = format!("{} || heatmap.retrieve_heatmap_oram geo_time_index(geo_time)",e.trace);
+                    e.trace = trace;
+                    return Err(e)
                 }
             };
             let mut bin_count = u64_a64(oram.read(oram_index))+1;
+            println!("retrieve_heatmap_oram oram_index {:?} bin_count {:?}",oram_index, bin_count);
             oram.write(oram_index, &a64_u64(bin_count));
-            println!("oram_index {:?} bin_count {:?}",oram_index, bin_count);
         }
     }
 
@@ -144,34 +166,30 @@
     let mut heatmap:HashMap<String,u64> = HashMap::new();
     for oram_index in 0..oram_len{
         let count = u64_a64(oram.read(oram_index));
-        // println!("retrieve_heatmap_oram bin {:?} count {:?}",oram_index, count);
+        let bin_str = format!("{},{}",oram_index/HEATMAP_GRANULARITY,oram_index%HEATMAP_GRANULARITY);
+        println!("retrieve_heatmap_oram add oram_index {:?} bin_str {:?} count {:?}",oram_index, bin_str, count);
         if count >= HEATMAP_COUNT_THRESHOLD.into() {
             let bin_str = format!("{},{}",oram_index/HEATMAP_GRANULARITY,oram_index%HEATMAP_GRANULARITY);
-            println!("retrieve_heatmap_oram add bin_str {:?} count {:?}",bin_str, count);
+            println!("\tretrieve_heatmap_oram add bin_str {:?} count {:?}",bin_str, count);
             heatmap.insert(bin_str,count);
         }
     }
 
-    let serialized_results = serde_json::to_string(&heatmap).map_err(|err| SystemError(SgxError{ err: err.to_string(), description:"heatmap serialize".to_string()}))?;
-    println!("serialized_results {:?}",serialized_results);
+    let serialized_results = serde_json::to_string(&heatmap).map_err(|e| EnclaveError{trace: "heatmap.retrieve_heatmap_oram serde_json::to_string(&heatmap)".to_string(), err: SgxError{description:format!("error serializing heatmap {:?}", e)}})?;
     let vec_u8_results:Vec<u8> = serialized_results.into();
-    println!("\tvec_u8_results={:?}",vec_u8_results);
 
     Ok(vec_u8_results)
-    // Ok(())
 }
 
 pub fn get_audit_data() -> Result<Vec<u8>, EnclaveError>{
     let mut audit_data_db = MultipartDatabase::<String>::load(String::from(AUDIT_DATA_NAME))?;
     let audit_data = audit_data_db.get_all()?;
     let user_addresses = audit_data.iter().map(|x| x.address_string() ).collect::<Vec<_>>();
-    println!("heatmap.get_audit_data {:?} {:?}",user_addresses.len(),user_addresses);
-    let serialized_results = serde_json::to_string(&user_addresses).map_err(|err| SystemError(SgxError{ err: err.to_string(), description:"get_audit_data serialize".to_string()}))?;
+    println!("heatmap.get_audit_data {:?} {:?}", user_addresses.len(),user_addresses);
+    let serialized_results = serde_json::to_string(&user_addresses).map_err(|e| EnclaveError{trace: "heatmap.get_audit_data serde_json::to_string(&user_addresses)".to_string(), err: SgxError{description:format!("error serializing user_addresses {:?}", e)}})?;
     let mut results:Vec<u8> = serialized_results.into();
     let mut vec_u8_results:Vec<u8>  = "AUDIT_DATA:".as_bytes().to_vec();
     vec_u8_results.append(&mut results);
-    println!("get_enclave_datavec_u8_results={:?}",vec_u8_results);
-
     Ok(vec_u8_results)
 }
 
@@ -190,18 +208,16 @@
     let mut result = A64Bytes::<N>::default();
     let val = val.to_be_bytes();
     // let mut i = 0;
-    println!("a64_u64 len before {:?}",result.len());
     for i in 0..8 {
         result[i] = val[i];
     }
-    println!("a64_u64 after len {:?}",result.len());
     result
 }
 
 fn u64_a64<N: ArrayLength<u8>>(val: A64Bytes<N>) -> u64 {
     let mut val_slice: [u8; 8] = [0;8];
     // println!("u64_a64 len {:?}",val.len());
-    val_slice.copy_from_slice(&val.as_slice()[0..8]);
+
     u64::from_be_bytes(val_slice)
 }
 
Index: enclave/enclave/src/storage.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/enclave/src/storage.rs b/enclave/enclave/src/storage.rs
--- a/enclave/enclave/src/storage.rs	
+++ b/enclave/enclave/src/storage.rs	(date 1663985193667)
@@ -8,7 +8,7 @@
 use std::untrusted::fs::File;
 use crate::crypto::asymmetric;
 
-use crate::types::{EnclaveError::{self, SystemError}, EnclaveSystemError::PermissionError};
+use crate::types::{EnclaveError, EnclaveErrorType::PermissionError};
 
 pub const SEALING_KEY_SIZE: usize = 32;
 pub const SEAL_LOG_SIZE: usize = 2048;
@@ -86,12 +86,9 @@
 pub fn save_sealed_key(path: &str, sealed_key: &[u8]) {
     let opt = File::create(path);
     if opt.is_ok() {
-        println!("Created file => {} ", path);
         let mut file = opt.unwrap();
         let result = file.write_all(&sealed_key);
-        if result.is_ok() {
-            println!("success writting to file! ");
-        } else {
+        if ! result.is_ok() {
             println!("error writting to file! ");
         }
     }
@@ -100,12 +97,9 @@
 pub fn load_sealed_key(path: &str, sealed_key: &mut [u8]) {
     let opt = File::open(path);
     if opt.is_ok() {
-        println!("Created file => {} ", path);
         let mut file = opt.unwrap();
         let result = file.read(sealed_key);
-        if result.is_ok() {
-            println!("success writting to file! ");
-        } else {
+        if ! result.is_ok() {
             println!("error writting to file! ");
         }
     }
@@ -124,7 +118,6 @@
             match SecretKeyStorage::unseal_key(&mut sealed) {
                 // If the data is unsealed correctly return this KeyPair.
                 Some(unsealed_data) => {
-                    println!("Succeeded reading key from file");
                     return Ok(asymmetric::KeyPair::from_slice(&unsealed_data.data)?);
                 }
                 // If the data couldn't get unsealed remove the file.
@@ -136,7 +129,7 @@
         }
         Err(err) => {
             if err.kind() == io::ErrorKind::PermissionDenied {
-                return Err(SystemError(PermissionError { file: sealed_path.to_string() }));
+                return Err(EnclaveError{trace:"storace.get_sealed_keys File::open(sealed_path)".to_string(),err: PermissionError { file: sealed_path.to_string() }});
             }
         }
     }
Index: enclave/enclave/src/user_db.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/enclave/src/user_db.rs b/enclave/enclave/src/user_db.rs
--- a/enclave/enclave/src/user_db.rs	
+++ b/enclave/enclave/src/user_db.rs	(date 1664007646300)
@@ -9,7 +9,9 @@
 
 use crate::{SIGNING_KEY,ENCRYPT_KEY};
 use crate::types::{PubKey, DhKey};
-use crate::types::{EnclaveError::{self, SystemError}, EnclaveSystemError::SgxError};
+
+use crate::types::{EnclaveError, EnclaveErrorType::SgxError};
+
 use crate::traits::EthereumAddress;
 use crate::multipart_data::MultipartDatabase;
 use crate::crypto;
@@ -21,87 +23,76 @@
 }
 
 pub const USER_DB_NAME: &str = "users";
-pub const MAX_USER_SIZE: usize = 8; //manually calculated based on Seal size and size of userinfo struct
+pub const MAX_USER_SIZE: usize = 7; //manually calculated based on Seal size and size of userinfo struct
 pub const USERID_SIZE: usize = 5;
 pub const PUBLICKEY_SIZE: usize = 128;
 
 lazy_static! { pub static ref USER_KEYS: SgxRwLock<HashMap<[u8; 5], (String, DhKey)>> = SgxRwLock::new(HashMap::new()); }
 
 pub fn init_user_db(database_str: &[u8]) -> Result<(), EnclaveError> {
-    println!("init_user_db database_str {:?} {:?}", MAX_USER_SIZE, database_str);
+    println!("user_db.init_user_db");
     let user_info: Vec<UserInfo> = match serde_json::from_slice(&database_str) {
         Ok(x) => x,
         Err(e) => {
-            let description = format!("user_db.init_user_db serde_json::from_slice(&database_str)");
-            println!("Error: {:?} {:?}",description,e);
-            return Err(SystemError(SgxError{err: e.to_string(), description}));
+            let trace = format!("user_db.init_user_db serde_json::from_slice(&database_str)");
+            return Err(EnclaveError{trace, err:SgxError{description: e.to_string()}});
         }
     };
+    println!("user_db.init_user_db user_info.len() {:?}", user_info.len());
 
     for ui in &user_info {
         if ui.userid.len() != USERID_SIZE {
-            let err = format!("wrong user id size {:?} != {:?}", ui.userid.len(), USERID_SIZE);
-            let description = format!("user_db.init_user_db ui.userid.len() != USERID_SIZE");
-            println!("Error: {:?} {:?}",description, err);
-            return Err(SystemError(SgxError{err, description}));
+            let description = format!("wrong user id size {:?} != {:?}", ui.userid.len(), USERID_SIZE);
+            let trace = format!("user_db.init_user_db ui.userid.len() != USERID_SIZE");
+            return Err(EnclaveError{trace, err:SgxError{description}});
         }
         if ui.publickey.len() != PUBLICKEY_SIZE {
-            let err = format!("wrong publickey size {:?} != {:?}", ui.publickey.len(), PUBLICKEY_SIZE);
-            let description = format!("user_db.init_user_db ui.publickey.len() != PUBLICKEY_SIZE");
-            println!("Error: {:?} {:?}",description, err);
-            return Err(SystemError(SgxError{err, description}));
+            let description = format!("wrong publickey size {:?} != {:?}", ui.publickey.len(), PUBLICKEY_SIZE);
+            let trace = format!("user_db.init_user_db ui.publickey.len() != PUBLICKEY_SIZE");
+            return Err(EnclaveError{trace, err:SgxError{description}});
         }
     }
-    println!("init_user_db user_info {:?}", user_info);
 
     let mut user_db = MultipartDatabase::<UserInfo>::create(String::from(USER_DB_NAME), MAX_USER_SIZE, false, user_info.clone());
-    println!("init_user_db user_db {:?}", user_info);
     match user_db.save() {
         Ok(_) => {},
         Err(e) => {
-            println!("init_user_db save err {:?}", e);
             return Err(e);
         }
     }
-    println!("init_user_db saved succesfully");
     setup_user_key_internal(user_info)
 }
 
 pub fn load_user_db() -> Result<(), EnclaveError> {
+    println!("user_db.load_user_db");
     let mut user_db = MultipartDatabase::<UserInfo>::load(String::from(USER_DB_NAME))?;
     let user_info = user_db.get_all()?;
     setup_user_key_internal(user_info)
 }
 
 pub fn get_enclave_data() -> Result<Vec<u8>, EnclaveError>{
+    println!("user_db.get_enclave_data");
     let mut data_db = MultipartDatabase::<UserInfo>::load(String::from(USER_DB_NAME))?;
     let user_info = data_db.get_all()?;
     let user_addresses = user_info.iter().map(|x| x.publickey.address_string() ).collect::<Vec<_>>();
-    let serialized_results = serde_json::to_string(&user_addresses).map_err(|err| EnclaveError::SystemError(SgxError{ err: err.to_string(), description:"get_enclave_data serialize".to_string()}))?;
+    let serialized_results = serde_json::to_string(&user_addresses).map_err(|err| EnclaveError{ trace: "user_db.get_enclave_data serde_json::to_string(&user_addresses)".to_string(), err:SgxError{description:err.to_string()}})?;
     let mut results:Vec<u8> = serialized_results.into();
     let mut vec_u8_results:Vec<u8>  = "ENCLAVE_DATA:".as_bytes().to_vec();
     vec_u8_results.append(&mut results);
-    println!("get_enclave_datavec_u8_results={:?}",vec_u8_results);
-
     Ok(vec_u8_results)
 }
 
 pub fn setup_user_key_internal(user_info: Vec<UserInfo>) -> Result<(), EnclaveError>{
-    println!("setup_user_key_internal");
     let mut user_info_lock = match USER_KEYS.write(){
         Ok(x) => x,
         Err(e) => {
-            let description = format!("user_db.setup_user_key_internal USER_KEYS.write()");
-            println!("Error: {:?} {:?}", description, e);
-            return Err(SystemError(SgxError{err:e.to_string(), description}));
+            let trace = format!("user_db.setup_user_key_internal USER_KEYS.write()");
+            return Err(EnclaveError{ trace, err:SgxError{description:e.to_string()}});
         }
     };
-    println!("setup_user_key_internal shaflkdshfaskjdfhlaskhdfjlsdif");
     for u in user_info {
         let pubkey_bytes = hex_to_bytes(&u.publickey);
         let userid_bytes = u.userid.as_bytes();
-
-        println!("setup_user_key_internal pubkey {:?}",&pubkey_bytes);
         let mut pubkey:PubKey= [0;64];
         pubkey.copy_from_slice(&pubkey_bytes[0..64]);
         let mut userid:[u8;5] = [0;5];
Index: enclave/enclave/src/multipart_data.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/enclave/src/multipart_data.rs b/enclave/enclave/src/multipart_data.rs
--- a/enclave/enclave/src/multipart_data.rs	
+++ b/enclave/enclave/src/multipart_data.rs	(date 1664071801727)
@@ -14,27 +14,9 @@
 
 use crate::serde::{Serialize, Deserialize, de::DeserializeOwned};
 
-use crate::types::{EnclaveError::{self, SystemError, UnsealError}, EnclaveSystemError::SgxError};
+use crate::types::{EnclaveError, EnclaveErrorType::{SgxError, UnsealError}};
 use crate::storage::SEAL_LOG_SIZE;
 
-/*
-#[derive(Serialize, Deserialize, Clone)]
-pub struct MultipartDatabase <T> where for<'de> T: Serialize + Deserialize<'de> + Clone {
-    name: String,
-    mutable: bool,
-    max_size: usize,
-    saved: bool,
-    len: usize,
-    parts: Vec<Part<T>>
-}
-
-#[derive(Serialize, Deserialize, Clone, Debug)]
-pub struct Part<T> where for<'de> T: Serialize + Deserialize<'de> + Clone {
-    index: usize,
-    data: Vec<T>,
-}
-*/
-
 #[derive(Serialize, Deserialize, Clone)]
 pub struct MultipartDatabase<T> {
     name: String,
@@ -54,6 +36,8 @@
 
 impl <T: Serialize+ for<'de> Deserialize<'de> + Clone> MultipartDatabase<T> {
     pub fn create(name: String, max_size: usize, mutable:bool, data: Vec<T>) -> MultipartDatabase<T> {
+        println!("multipart_data.create name {:?} max_size {:?} mutable {:?} data.len {:?}",
+                 &name, max_size, mutable, data.len());
         let mut num_parts = data.len() / max_size;
         if data.len() % max_size != 0 {
             num_parts+=1
@@ -70,54 +54,55 @@
     }
 
     pub fn load(name: String) -> Result<MultipartDatabase<T>, EnclaveError> {
-        println!("load");
+        println!("multipart_data.load name {:?}", name);
         let sealed_path = MultipartDatabase::<T>::_get_path(name);
         if !sealed_path.exists() {
-            return Err(EnclaveError::SystemError(SgxError{err:"path does not exists call save".to_string(),description:"path not exists".to_string()}));
+            let description = format!("sealed_path for {:?} does not exist",sealed_path);
+            return Err(EnclaveError{trace:"multipart_data.load !sealed_path.exists()".to_string(),err:SgxError{description}});
         }
         let sealed_path = match sealed_path.to_str() {
             Some(x) => x,
             None => {
-                return Err(EnclaveError::SystemError(SgxError{err:"seal_oath ".to_string(),description:"seal path error".to_string()}));
+                let description = format!("could not convert sealed_path {:?} to str",sealed_path);
+                return Err(EnclaveError{trace:"multipart_data.load sealed_path.to_str()".to_string(), err: SgxError{description}});
             }
         };
-        println!("load sealed_path {:?}",sealed_path);
         let mut sealed_log_out = [0u8; SEAL_LOG_SIZE];
         match load_sealed_data(&sealed_path, &mut sealed_log_out) {
             Ok(_) => {
 
             },
-            Err(err) => {
-                return Err(EnclaveError::SystemError(SgxError{err: err.to_string(), description:"load call load_sealed_data".to_string()}));
+            Err(e) => {
+                let trace = format!("{} || multipart_data.load load_sealed_data(&sealed_path, &mut sealed_log_out)", e.trace);
+                return Err(EnclaveError{trace, err:e.err});
             }
         };
-        println!("load load_sealed_data");
 
         let sealed_log = sealed_log_out.as_mut_ptr();
         let db_info:MultipartDatabase<T> = match recover_sealeddata_for_serializable(sealed_log, SEAL_LOG_SIZE as u32) {
             Ok(x) => x,
-            Err(err) => {
-                println!("load recover_sealeddata_for_serializable_part err {:?}",err);
-                return Err(EnclaveError::SystemError(SgxError{err: err.to_string(), description:"load call recover_sealeddata_for_serializable".to_string()}));
+            Err(e) => {
+                let trace = format!("{} || multipart_data.load recover_sealeddata_for_serializable(sealed_log, SEAL_LOG_SIZE)", e.trace);
+                return Err(EnclaveError{trace, err:e.err});
             }
         };
-        println!("load recover_sealeddata_for_serializable_part");
 
         let db = MultipartDatabase{name: db_info.name, mutable: db_info.mutable, max_size:db_info.max_size, saved: db_info.saved, len: db_info.len, parts: Vec::new()};
         return Ok(db);
     }
 
     pub fn save(&mut self) -> Result<(),EnclaveError> {
-        // if self.saved && !self.mutable {todo uncomment and reformat
-        //     return Err(EnclaveError::SystemError(SgxError{err:"already saved ".to_string(),description:"already saved and not mutable".to_string()}));
+        println!("multipart_data.save {:?}", self.name);
+        // if self.saved && !self.mutable {
+        //     let description = format!("database {:?} was already saved and is not mutable saved {:?} mutable {:?}", self.name, self.saved, self.mutable);
+        //     return Err(EnclaveError{trace:"multipart_data.save self.saved && !self.mutable".to_string(), err:SgxError{description});
         // }
         for part in &self.parts {
             match self.save_part(part) {
                 Ok(_) => {},
                 Err(e) => {
-                    let description = format!("multipart_data.save self.save_part(part)");
-                    println!("Error: {:?} {:?}",description, e);
-                    return Err(SystemError(SgxError{ err: e.to_string(), description}))
+                    let trace = format!("{} || multipart_data.save self.save_part(part)", e.trace);
+                    return Err(EnclaveError{trace, err:e.err});
                 }
             }
         }
@@ -127,9 +112,8 @@
             Ok(_) => {},
             Err(e) => {
                 self.saved = false;
-                let description = format!("multipart_data.save self.save_db()");
-                println!("Error: {:?} {:?}",description, e);
-                return Err(SystemError(SgxError{ err: e.to_string(), description}))
+                let trace = format!("{} || multipart_data.save self.save_db()", e.trace);
+                return Err(EnclaveError{trace, err:e.err});
             }
         }
 
@@ -137,32 +121,30 @@
     }
 
     pub fn append(&mut self, data:Vec<T>) -> Result<(),EnclaveError>{
-        println!("append {:?}",data.len());
+        println!("multipart_data.append name {:?} data.len {:?}", self.name, data.len());
         // if self.saved && !self.mutable {TODO uncomment
-        //     return Err(EnclaveError::SystemError(SgxError{err:"already saved ".to_string(),description:"already saved and not mutable".to_string()}));
+        //     let description = format!("database {:?} was already saved and is not mutable saved {:?} mutable {:?}", self.name, self.saved, self.mutable);
+        //     return Err(EnclaveError{trace:"multipart_data.append self.saved && !self.mutable".to_string(), err:SgxError{description}});
         // }
         let mut num_append = 0;
         let mut next_part_index = 0;
         if self.len > 0 {
             let last_part_index = self.len - 1;
             next_part_index = self.len;
-            let seal_path = self.get_part_path(last_part_index as usize);
-            let seal_path: &str = match seal_path.to_str() {
+            let sealed_path = self.get_part_path(last_part_index as usize);
+            let sealed_path: &str = match sealed_path.to_str() {
                 Some(x) => x,
                 None => {
-                    let err = format!("coundn't convert seal_path to str");
-                    let description = format!("multipart_data.append seal_path.to_str()");
-                    println!("Error: {:?} {:?}",description, err);
-                    return Err(SystemError(SgxError{err, description}));
+                    let description = format!("could not convert sealed_path {:?} to str",sealed_path);
+                    return Err(EnclaveError{err:SgxError {description},trace:"multipart_data.append sealed_path.to_str()".to_string()});
                 }
             };
             let mut sealed_log_out = [0u8; SEAL_LOG_SIZE];
-            match load_sealed_data(&seal_path, &mut sealed_log_out) {
+            match load_sealed_data(&sealed_path, &mut sealed_log_out) {
                 Ok(_) => {},
                 Err(e) => {
-                    let description = format!("multipart_data.append load_sealed_data");
-                    println!("Error: {:?} {:?}",description, e);
-                    return Err(SystemError(SgxError{err: e.to_string(), description}));
+                    let trace = format!("{} || multipart_data.append load_sealed_data(&sealed_path, &mut sealed_log_out)", e.trace);
+                    return Err(EnclaveError{trace, err:e.err});
                 }
             };
 
@@ -170,7 +152,8 @@
             let mut last_part = match recover_sealeddata_for_serializable_part(sealed_log, SEAL_LOG_SIZE as u32) {
                 Ok(x) => x,
                 Err(e) => {
-                    return Err(EnclaveError::SystemError(SgxError { err: e.to_string(), description: "unseal_data_wrapper call load_sealed_data".to_string() }));
+                    let trace = format!("{} || multipart_data.append recover_sealeddata_for_serializable(sealed_log, SEAL_LOG_SIZE)", e.trace);
+                    return Err(EnclaveError{trace, err:e.err});
                 }
             };
 
@@ -179,7 +162,13 @@
                 for i in 0..num_append {
                     last_part.data.push(data[i].clone());
                 }
-                self.save_part(&last_part);
+                match self.save_part(&last_part) {
+                    Ok(_) => {},
+                    Err(e) => {
+                        let trace = format!("{} || multipart_data.append self.save_part(&last_part)", e.trace);
+                        return Err(EnclaveError{trace, err:e.err});
+                    }
+                }
             }
         }
 
@@ -198,8 +187,9 @@
                 let new_part = Part{index, data:(&data[start_i..end_i]).to_vec()};
                 match self.save_part(&new_part) {
                     Ok(_) => {},
-                    Err(err) => {
-                        return Err(EnclaveError::SystemError(SgxError{err: err.to_string(), description:"unseal_data_wrapper call load_sealed_data".to_string()}));
+                    Err(e) => {
+                        let trace = format!("{} || multipart_data.append self.save_part(&new_part)", e.trace);
+                        return Err(EnclaveError{trace, err:e.err});
                     }
                 }
             }
@@ -213,7 +203,8 @@
                 Err(e) => {
                     self.saved = old_saved;
                     self.len = old_len;
-                    return Err(EnclaveError::SystemError(SgxError{ err: e.to_string(), description:"save_db".to_string()}))
+                    let trace = format!("{} || multipart_data.append self.save_db()", e.trace);
+                    return Err(EnclaveError{trace, err:e.err});
                 }
             }
         }
@@ -221,9 +212,10 @@
     }
 
     pub fn get(&mut self, index: usize) -> Result<Vec<T>,EnclaveError>  {
-        println!("get index {:?} len {:?}",index,self.len);
+        println!("multipart_data.get name {:?} index {:?} self.len {:?}", self.name, index, self.len);
         if index >= self.len {
-            return Err(EnclaveError::SystemError(SgxError{err: "index out of bounds".to_string(), description:"get multipart_data".to_string()}));
+            let description = format!("index out of bounds index {:?} self.len {:?}",index, self.len);
+            return Err(EnclaveError{trace: "multipart_data.get index >= self.len".to_string(), err:SgxError{description}});
         }
         for p in &self.parts {
             if p.index == index {
@@ -232,18 +224,22 @@
         }
         match self.load_part(index) {
             Ok(x) => Ok(x.data),
-            Err(e) => Err(e),
+            Err(e) => {
+                let trace = format!("{} || multipart_data.get self.load_part(index)", e.trace);
+                Err(EnclaveError{trace, err:e.err})
+            }
         }
     }
 
     pub fn get_all(&mut self) -> Result<Vec<T>,EnclaveError>  {
-        println!("get_all");
+        println!("multipart_data.get_all {:?}", self.name);
         let mut all = Vec::new();
         for index in 0..self.len {
             match self.load_part(index) {
                 Ok(mut x) => all.append(&mut x.data),
                 Err(e) => {
-                    return Err(e);
+                    let trace = format!("{} || multipart_data.get_all self.load_part(index)", e.trace);
+                    return Err(EnclaveError{trace, err:e.err});
                 },
             }
         }
@@ -253,30 +249,29 @@
     pub fn len(&self) -> usize {
         self.len
     }
+
     fn save_db(&self) -> Result<(), EnclaveError> {
-        println!("save_db");
         let sealed_path = self.get_path();
         // if sealed_path.exists() && !self.mutable { todo uncomment
-        //     println!("save_db err path exists {:?}", sealed_path);
-        //     return Err(EnclaveError::SystemError(SgxError{err:"path exists".to_string(),description:"path exists and not mutable".to_string()}));
+        //     return Err(SgxError{err:"path exists".to_string(),description:"path exists and not mutable".to_string()});
         // }
         let sealed_path = match sealed_path.to_str() {
             Some(x) => x,
             None => {
-                println!("save_dbcall sealed_path.to_str None");
-                return Err(EnclaveError::SystemError(SgxError{err:"sealed_path.to_str None".to_string(),description:"sealed_path.to_str None".to_string()}));
+                let description = format!("could not convert sealed_path {:?} to str",sealed_path);
+                return Err(EnclaveError{err:SgxError {description},trace:"multipart_data.save_db sealed_path.to_str()".to_string()});
             }
         };
         let db_info:MultipartDatabase<T> = MultipartDatabase{name: self.name.clone(), mutable: self.mutable, max_size: self. max_size, saved: self.saved, len: self.len, parts: Vec::new()};
         let encoded_vec = serde_json::to_vec(&db_info).unwrap();
+        println!("encoded_vec len {:?} {:?}",encoded_vec.len(), encoded_vec);
         let encoded_slice = encoded_vec.as_slice();
         let aad: [u8; 0] = [0_u8; 0];
         let result = SgxSealedData::<[u8]>::seal_data(&aad, encoded_slice);
         let sealed_data = match result {
             Ok(x) => x,
-            Err(ret) => {
-                println!("save_dbcall SgxSealedData::seal_data err: {:?}", ret);
-                return Err(EnclaveError::SystemError(SgxError{err:ret.to_string(), description:"save_dbcall SgxSealedData::seal_data".to_string()}));
+            Err(e) => {
+                return Err(EnclaveError{trace:"multipart_data.save_db SgxSealedData::<[u8]>::seal_data(&aad, encoded_slice)".to_string(), err: SgxError{description: e.to_string()}});
             },
         };
         let mut sealed_log_out = [0u8; SEAL_LOG_SIZE];
@@ -285,60 +280,61 @@
         let opt = to_sealed_log_for_slice(&sealed_data, sealed_log, SEAL_LOG_SIZE as u32);
 
         if opt.is_none() {
-            println!("save_dbcall to_sealed_log_for_slice opt.is_none() None");
-            return Err(EnclaveError::SystemError(SgxError{ err: "opt.is_none()".to_string(), description:"update_part_len call to_sealed_log_for_slice".to_string()}))
+            let description = format!("to_sealed_log_for_slice failed for sealed_path {:?}", sealed_path);
+            return Err(EnclaveError{trace: "multipart_data.save_db opt.is_none()".to_string(), err:SgxError{description}});
         }
         match save_sealed_data(sealed_path, &sealed_log_out){
             Ok(_) => {},
             Err(e) => {
-                println!("save_dbcall save_sealed_data err {:?}",e);
-                return Err(EnclaveError::SystemError(SgxError{ err: e.to_string(), description:"update_part_len call save_sealed_data".to_string()}));
+                let trace = format!("{} || multipart_data.save_db save_sealed_data", e.trace);
+                return Err(EnclaveError{trace, err: e.err});
             }
         }
         Ok(())
     }
 
     fn save_part(&self, part:&Part<T>) -> Result<(),EnclaveError> {
-        println!("save_part {:?}",part.index);
-        let seal_path = self.get_part_path(part.index);
-        // if seal_path.exists() && !self.mutable {todo uncomment
-        //     return Err(EnclaveError::SystemError(SgxError{err:"path exists".to_string(),description:"path exists and not mutable".to_string()}));
+        let sealed_path = self.get_part_path(part.index);
+        // if sealed_path.exists() && !self.mutable {todo uncomment
+        //     return Err(SgxError{err:"path exists".to_string(),description:"path exists and not mutable".to_string()});
         // }
-        println!("save_part seal_path {:?}",seal_path);
-        let seal_path:&str = match seal_path.to_str() {
+        let sealed_path:&str = match sealed_path.to_str() {
             Some(x) => x,
             None => {
-                return Err(EnclaveError::SystemError(SgxError{err:"seal_path ".to_string(),description:"seal part path error".to_string()}));
+                let description = format!("could not convert sealed_path {:?} to str",sealed_path);
+                return Err(EnclaveError{trace: "multipart_data.save_part sealed_path.to_str()".to_string(), err:SgxError{description}});
             }
         };
 
         let encoded_part_vec = serde_json::to_vec(&part).unwrap();
-        println!("save_part encoded_part_vec {:?}", encoded_part_vec.len());
         let encoded_part_slice = encoded_part_vec.as_slice();
         let part_aad: [u8; 0] = [0_u8; 0];
         let part_result = SgxSealedData::<[u8]>::seal_data(&part_aad, encoded_part_slice);
         let sealed_part_data = match part_result {
             Ok(x) => x,
-            Err(ret) => {
-                println!("save_part seal_data err: {:?}", ret);
-                return Err(EnclaveError::SystemError(SgxError{err:ret.to_string(), description:"create_sealeddata_for_serializable_vec call seal_data".to_string()}));
+            Err(e) => {
+                return Err(EnclaveError{trace:"multipart_data.save_part SgxSealedData::<[u8]>::seal_data(&aad, encoded_slice)".to_string(), err:SgxError{description: e.to_string()}});
             },
         };
         let mut sealed_part_log_out = [0u8; SEAL_LOG_SIZE];
 
         let sealed_part_log = sealed_part_log_out.as_mut_ptr();
+        use std;
+        // println!("part.data.len {:?}", part.data.len());
+        // println!("encoded_part_vec len {:?} {:?} {:?}",encoded_part_vec.len(), SEAL_LOG_SIZE as u32,  std::str::from_utf8(&encoded_part_vec).unwrap());
         let part_opt = to_sealed_log_for_slice(&sealed_part_data, sealed_part_log, SEAL_LOG_SIZE as u32);
-        println!("opt {:?} {:?}", part_opt, part_opt.is_none());
         if part_opt.is_none() {
-            return Err(EnclaveError::SystemError(SgxError{err:"opt.is_none()".to_string(),description:"create_sealeddata_for_serializable_vec call to_sealed_log_for_slice".to_string()}));
+            let description = format!("to_sealed_log_for_slice failed for sealed_path {:?}", sealed_path);
+            return Err(EnclaveError{trace: "multipart_data.save_part part_opt.is_none()".to_string(), err:SgxError{description}});
         }
 
-        match save_sealed_data(seal_path, &sealed_part_log_out) {
+        match save_sealed_data(sealed_path, &sealed_part_log_out) {
             Ok(_) => {
                 return Ok(());
             },
             Err(e) => {
-                return Err(EnclaveError::SystemError(SgxError{ err: e.to_string(), description:"update_part_len call save_sealed_data".to_string()}));
+                let trace = format!("{} || multipart_data.save_part save_sealed_data(sealed_path, &sealed_part_log_out)", e.trace);
+                return Err(EnclaveError{trace, err: e.err});
             }
         }
     }
@@ -346,35 +342,36 @@
     fn load_part(&mut self, index: usize) -> Result<Part<T>, EnclaveError> {
         let sealed_path = self.get_part_path(index);
         if !sealed_path.exists() {
-            return Err(EnclaveError::SystemError(SgxError{err:"part path does not exists call save".to_string(),description:"part path not exists".to_string()}));
+            let description = format!("sealed_path for {:?} does not exist",sealed_path);
+            return Err(EnclaveError{err:SgxError {description}, trace:"multipart_data.load_part !sealed_path.exists()".to_string()});
         }
         let sealed_path:&str = match sealed_path.to_str() {
             Some(x) => x,
             None => {
-                return Err(EnclaveError::SystemError(SgxError{err:"seal_part_path ".to_string(),description:"seal part path error".to_string()}));
+                let description = format!("could not convert sealed_path {:?} to str",sealed_path);
+                return Err(EnclaveError{err:SgxError {description},trace:"multipart_data.load_part sealed_path.to_str()".to_string()});
             }
         };
 
         let mut sealed_log_out = [0u8; SEAL_LOG_SIZE];
         match load_sealed_data(&sealed_path, &mut sealed_log_out) {
-            Ok(_) => {
-
-            },
-            Err(err) => {
-                return Err(EnclaveError::SystemError(SgxError{err: err.to_string(), description:"unseal_data_wrapper call load_sealed_data".to_string()}));
+            Ok(_) => {},
+            Err(e) => {
+                let trace = format!("{} || multipart_data.load_part load_sealed_data(&sealed_path, &mut sealed_log_out)", e.trace);
+                return Err(EnclaveError{trace, err: e.err});
             }
         };
         let sealed_log = sealed_log_out.as_mut_ptr();
         let part = match recover_sealeddata_for_serializable_part(sealed_log, SEAL_LOG_SIZE as u32) {
             Ok(x) => x,
-            Err(err) => {
-                return Err(EnclaveError::SystemError(SgxError{err: err.to_string(), description:"unseal_data_wrapper call load_sealed_data".to_string()}));
+            Err(e) => {
+                let trace = format!("{} || multipart_data.load_part recover_sealeddata_for_serializable_part(sealed_log, SEAL_LOG_SIZE)", e.trace);
+                return Err(EnclaveError{trace, err: e.err});
             }
         };
-        println!("load_part recover_sealeddata_for_serializable_part");
+        println!("load_part part.data.len {:?}", part.data.len());
         let p = part.clone();
         self.parts.push(part);
-        println!("load_part push part");
         Ok(p)
     }
 
@@ -392,53 +389,48 @@
 }
 
 // Save sealed data to disk
-pub fn save_sealed_data(path: &str, sealed_data: &[u8]) -> Result<(), String>  {
-    println!("save_sealed_data path {:} ",path);
+pub fn save_sealed_data(path: &str, sealed_data: &[u8]) -> Result<(), EnclaveError>  {
     let opt = File::create(path);
     if opt.is_ok() {
-        println!("Created file => {} ", path);
         let mut file = opt.unwrap();
-        let result = file.write_all(&sealed_data);
-        if result.is_ok() {
-            println!("success writting to file! ");
-        } else {
-            println!("error writting to file! ");
-            return Err(format!("error writting to file {:?}",path));
+        match file.write_all(&sealed_data) {
+            Ok(_) => {},
+            Err(e) => {
+                let description = format!("error writing to file {:?} {:?}", path, file.write_all(&sealed_data));
+                return Err(EnclaveError{err:SgxError {description}, trace: "multipart_data.save_sealed_data file.write_all(&sealed_data)".to_string() });
+            }
         }
     } else {
-        println!("error creating filerror creating file!e! ");
-        return Err(format!("error creating file {:?}",path));
+        let description = format!("error creating to file {:?} {:?}",path, opt);
+        return Err(EnclaveError{err:SgxError {description}, trace:"multipart_data.save_sealed_data file.create(path)".to_string()});
     }
     Ok(())
 }
 
-pub fn load_sealed_data(path: &str, sealed_data: &mut [u8]) -> Result<(), String> {
+pub fn load_sealed_data(path: &str, sealed_data: &mut [u8]) -> Result<(), EnclaveError> {
     let mut file = match File::open(path) {
-        Err(why) => return Err(why.to_string()),
+        Err(e) => {
+            let description = format!("error opening to file {:?} {:?}", path, e);
+            return Err(EnclaveError{err:SgxError {description}, trace: "multipart_data.load_sealed_data File::open(path)".to_string() });
+        }
         Ok(file) => file,
     };
 
-    println!("Opened file => {:?} ", path);
-
     let result = file.read(sealed_data);
     if result.is_ok() {
-        println!("success reading from file! ");
         return Ok(());
     } else {
-        println!("error reading from file! ");
-        return Err(format!("error reading from file {:?}",path));
+        let description = format!("error reading to file {:?} {:?}",path, result);
+        return Err(EnclaveError{err:SgxError {description}, trace:"multipart_data.load_sealed_data file.read(path)".to_string()});
+
     }
 }
 
 pub fn recover_sealeddata_for_serializable<T: DeserializeOwned>(sealed_log: * mut u8, sealed_log_size: u32) -> Result<MultipartDatabase<T>, EnclaveError> {
 
-    let sealed_data = from_sealed_log_for_slice::<u8>(sealed_log, sealed_log_size).ok_or(UnsealError)?;
-    let unsealed_data = sealed_data.unseal_data().map_err(|err| SystemError(SgxError{err: err.to_string(), description: err.to_string()}))?;
+    let sealed_data = from_sealed_log_for_slice::<u8>(sealed_log, sealed_log_size).ok_or(EnclaveError{err:UnsealError, trace:"multipart_data.recover_sealeddata_for_serializable from_sealed_log_for_slice".to_string()})?;
+    let unsealed_data = sealed_data.unseal_data().map_err(|err| EnclaveError{trace: "multipart_data.recover_sealeddata_for_serializable sealed_data.unseal_data()".to_string(), err:SgxError{description: err.to_string()}})?;
     let encoded_slice = unsealed_data.get_decrypt_txt();
-
-    // println!("Length of encoded slice: {}", encoded_slice.len());
-    // println!("Encoded slice: {:?}", encoded_slice);
-
     let data: MultipartDatabase<T> = serde_json::from_slice(encoded_slice).unwrap();
 
     Ok(data)
@@ -446,13 +438,10 @@
 
 pub fn recover_sealeddata_for_serializable_part<T: DeserializeOwned>(sealed_log: * mut u8, sealed_log_size: u32) -> Result<Part<T>, EnclaveError> {
 
-    let sealed_data = from_sealed_log_for_slice::<u8>(sealed_log, sealed_log_size).ok_or(UnsealError)?;
-    let unsealed_data = sealed_data.unseal_data().map_err(|err| SystemError(SgxError{err: err.to_string(), description: err.to_string()}))?;
+    let sealed_data = from_sealed_log_for_slice::<u8>(sealed_log, sealed_log_size).ok_or(EnclaveError{err:UnsealError, trace:"multipart_data.recover_sealeddata_for_serializable_part from_sealed_log_for_slice".to_string()})?;
+    let unsealed_data = sealed_data.unseal_data().map_err(|err| EnclaveError{trace: "multipart_data.recover_sealeddata_for_serializable_part sealed_data.unseal_data()".to_string(), err:SgxError{description: err.to_string()}})?;
     let encoded_slice = unsealed_data.get_decrypt_txt();
 
-    // println!("Length of encoded slice: {}", encoded_slice.len());
-    // println!("Encoded slice: {:?}", encoded_slice);
-
     let data: Part<T> = serde_json::from_slice(encoded_slice).unwrap();
 
     Ok(data)
Index: enclave/enclave/target/release/.fingerprint/num-traits-cdf540d0e8f69681/run-build-script-build-script-build.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/enclave/target/release/.fingerprint/num-traits-cdf540d0e8f69681/run-build-script-build-script-build.json b/enclave/enclave/target/release/.fingerprint/num-traits-cdf540d0e8f69681/run-build-script-build-script-build.json
--- a/enclave/enclave/target/release/.fingerprint/num-traits-cdf540d0e8f69681/run-build-script-build-script-build.json	
+++ b/enclave/enclave/target/release/.fingerprint/num-traits-cdf540d0e8f69681/run-build-script-build-script-build.json	(date 1664071062446)
@@ -1,0 +1,1 @@
+{"rustc":16864309158671632917,"features":"","target":0,"profile":0,"path":0,"deps":[[2772652600746072486,"build_script_build",false,5062635458960442195]],"local":[{"RerunIfChanged":{"output":"release/build/num-traits-cdf540d0e8f69681/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
\ No newline at end of file
Index: enclave/enclave/target/release/.fingerprint/heatmap-enclave-278be894e905165c/output-lib-heatmapenclave
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/enclave/target/release/.fingerprint/heatmap-enclave-278be894e905165c/output-lib-heatmapenclave b/enclave/enclave/target/release/.fingerprint/heatmap-enclave-278be894e905165c/output-lib-heatmapenclave
--- a/enclave/enclave/target/release/.fingerprint/heatmap-enclave-278be894e905165c/output-lib-heatmapenclave	
+++ b/enclave/enclave/target/release/.fingerprint/heatmap-enclave-278be894e905165c/output-lib-heatmapenclave	(date 1664076409822)
@@ -7,19 +7,41 @@
 {"message":"unused imports: `U2048`, `U4096`, `U64`, `U8192`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/heatmap.rs","byte_start":254,"byte_end":259,"line_start":10,"line_end":10,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"use aligned_cmov::typenum::{U8192, U2048, U4096, U64};","highlight_start":29,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/heatmap.rs","byte_start":261,"byte_end":266,"line_start":10,"line_end":10,"column_start":36,"column_end":41,"is_primary":true,"text":[{"text":"use aligned_cmov::typenum::{U8192, U2048, U4096, U64};","highlight_start":36,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/heatmap.rs","byte_start":268,"byte_end":273,"line_start":10,"line_end":10,"column_start":43,"column_end":48,"is_primary":true,"text":[{"text":"use aligned_cmov::typenum::{U8192, U2048, U4096, U64};","highlight_start":43,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/heatmap.rs","byte_start":275,"byte_end":278,"line_start":10,"line_end":10,"column_start":50,"column_end":53,"is_primary":true,"text":[{"text":"use aligned_cmov::typenum::{U8192, U2048, U4096, U64};","highlight_start":50,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/heatmap.rs","byte_start":226,"byte_end":280,"line_start":10,"line_end":10,"column_start":1,"column_end":55,"is_primary":true,"text":[{"text":"use aligned_cmov::typenum::{U8192, U2048, U4096, U64};","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `U2048`, `U4096`, `U64`, `U8192`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/heatmap.rs:10:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse aligned_cmov::typenum::{U8192, U2048, U4096, U64};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\n"}
 {"message":"unused import: `PubKey`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/heatmap.rs","byte_start":536,"byte_end":542,"line_start":18,"line_end":18,"column_start":20,"column_end":26,"is_primary":true,"text":[{"text":"use crate::types::{PubKey, DhKey};","highlight_start":20,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/heatmap.rs","byte_start":536,"byte_end":544,"line_start":18,"line_end":18,"column_start":20,"column_end":28,"is_primary":true,"text":[{"text":"use crate::types::{PubKey, DhKey};","highlight_start":20,"highlight_end":28}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `PubKey`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/heatmap.rs:18:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse crate::types::{PubKey, DhKey};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\n\n"}
 {"message":"unused import: `self::CryptoError::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/types.rs","byte_start":1965,"byte_end":1985,"line_start":72,"line_end":72,"column_start":13,"column_end":33,"is_primary":true,"text":[{"text":"        use self::CryptoError::*;","highlight_start":13,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/types.rs","byte_start":1961,"byte_end":1986,"line_start":72,"line_end":72,"column_start":9,"column_end":34,"is_primary":true,"text":[{"text":"        use self::CryptoError::*;","highlight_start":9,"highlight_end":34}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `self::CryptoError::*`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/types.rs:72:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        use self::CryptoError::*;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
+{"message":"unused import: `ToString`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/traits.rs","byte_start":90,"byte_end":98,"line_start":2,"line_end":2,"column_start":26,"column_end":34,"is_primary":true,"text":[{"text":"use std::string::{String,ToString};","highlight_start":26,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/traits.rs","byte_start":89,"byte_end":98,"line_start":2,"line_end":2,"column_start":25,"column_end":34,"is_primary":true,"text":[{"text":"use std::string::{String,ToString};","highlight_start":25,"highlight_end":34}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `ToString`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/traits.rs:2:26\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse std::string::{String,ToString};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n\n"}
 {"message":"unused import: `Path`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/multipart_data.rs","byte_start":164,"byte_end":168,"line_start":8,"line_end":8,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"use std::path::{Path, PathBuf};","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/multipart_data.rs","byte_start":164,"byte_end":170,"line_start":8,"line_end":8,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"use std::path::{Path, PathBuf};","highlight_start":17,"highlight_end":23}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `Path`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/multipart_data.rs:8:17\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse std::path::{Path, PathBuf};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
 {"message":"unused import: `sgx_status_t`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/multipart_data.rs","byte_start":225,"byte_end":237,"line_start":11,"line_end":11,"column_start":17,"column_end":29,"is_primary":true,"text":[{"text":"use sgx_types::{sgx_status_t, sgx_sealed_data_t};","highlight_start":17,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/multipart_data.rs","byte_start":225,"byte_end":239,"line_start":11,"line_end":11,"column_start":17,"column_end":31,"is_primary":true,"text":[{"text":"use sgx_types::{sgx_status_t, sgx_sealed_data_t};","highlight_start":17,"highlight_end":31}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `sgx_status_t`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/multipart_data.rs:11:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse sgx_types::{sgx_status_t, sgx_sealed_data_t};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\n\n"}
+{"message":"the item `std` is imported redundantly","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":1027,"byte_end":1056,"line_start":27,"line_end":27,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"extern crate sgx_tstd as std;","highlight_start":1,"highlight_end":30}],"label":"the item `std` is already imported here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/multipart_data.rs","byte_start":13930,"byte_end":13933,"line_start":322,"line_end":322,"column_start":13,"column_end":16,"is_primary":true,"text":[{"text":"        use std;","highlight_start":13,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: the item `std` is imported redundantly\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/multipart_data.rs:322:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m322\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        use std;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/lib.rs:27:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m27\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mextern crate sgx_tstd as std;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe item `std` is already imported here\u001b[0m\n\n"}
+{"message":"unused import: `std`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/multipart_data.rs","byte_start":13930,"byte_end":13933,"line_start":322,"line_end":322,"column_start":13,"column_end":16,"is_primary":true,"text":[{"text":"        use std;","highlight_start":13,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/multipart_data.rs","byte_start":13926,"byte_end":13934,"line_start":322,"line_end":322,"column_start":9,"column_end":17,"is_primary":true,"text":[{"text":"        use std;","highlight_start":9,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/multipart_data.rs:322:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m322\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        use std;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\n"}
 {"message":"unused import: `Path`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":1563,"byte_end":1567,"line_start":56,"line_end":56,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"use std::path::{Path, PathBuf};","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":1563,"byte_end":1569,"line_start":56,"line_end":56,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"use std::path::{Path, PathBuf};","highlight_start":17,"highlight_end":23}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `Path`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:56:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse std::path::{Path, PathBuf};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
 {"message":"unused import: `reset_heatmap`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":1879,"byte_end":1892,"line_start":69,"line_end":69,"column_start":66,"column_end":79,"is_primary":true,"text":[{"text":"use heatmap::{add_personal_data_internal, retrieve_heatmap_oram, reset_heatmap, get_audit_data};","highlight_start":66,"highlight_end":79}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":1877,"byte_end":1892,"line_start":69,"line_end":69,"column_start":64,"column_end":79,"is_primary":true,"text":[{"text":"use heatmap::{add_personal_data_internal, retrieve_heatmap_oram, reset_heatmap, get_audit_data};","highlight_start":64,"highlight_end":79}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `reset_heatmap`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:69:66\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m69\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse heatmap::{add_personal_data_internal, retrieve_heatmap_oram, reset_heatmap, get_audit_data};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\n\n"}
-{"message":"attribute should be applied to a free function, impl method or static","code":{"code":"unused_attributes","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":3214,"byte_end":3877,"line_start":105,"line_end":113,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"extern \"C\" {","highlight_start":1,"highlight_end":13},{"text":"    fn ocall_save_to_memory(ptr: *mut u64, data_ptr: *const u8, data_len: usize) -> sgx_status_t;","highlight_start":1,"highlight_end":98},{"text":"    fn allocate_oram_storage(count: u64, data_size: u64, meta_size: u64, id_out: *mut u64);// -> sgx_status_t;","highlight_start":1,"highlight_end":111},{"text":"    fn release_oram_storage(id: u64);// -> sgx_status_t;","highlight_start":1,"highlight_end":57},{"text":"    fn checkout_oram_storage( id: u64, idx: *const u64, idx_len: usize, databuf: *mut u64,","highlight_start":1,"highlight_end":91},{"text":"        databuf_len: usize, metabuf: *mut u64, metabuf_len: usize);// -> sgx_status_t;","highlight_start":1,"highlight_end":87},{"text":"    fn checkin_oram_storage( id: u64, idx: *const u64, idx_len: usize, databuf: *const u64,","highlight_start":1,"highlight_end":92},{"text":"                                databuf_len: usize, metabuf: *const u64, metabuf_len: usize);// -> sgx_status_t;","highlight_start":1,"highlight_end":113},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"not a free function, impl method or static","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":3201,"byte_end":3213,"line_start":104,"line_end":104,"column_start":1,"column_end":13,"is_primary":true,"text":[{"text":"#[no_mangle]","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_attributes)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!","code":null,"level":"warning","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: attribute should be applied to a free function, impl method or static\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:104:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m#[no_mangle]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mextern \"C\" {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m106\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn ocall_save_to_memory(ptr: *mut u64, data_ptr: *const u8, data_len: usize) -> sgx_status_t;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m107\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn allocate_oram_storage(count: u64, data_size: u64, meta_size: u64, id_out: *mut u64);// -> sgx_status_t;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn release_oram_storage(id: u64);// -> sgx_status_t;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                databuf_len: usize, metabuf: *const u64, metabuf_len: usize);// -> sgx_status_t;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mnot a free function, impl method or static\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_attributes)]` on by default\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\u001b[0m\n\n"}
+{"message":"attribute should be applied to a free function, impl method or static","code":{"code":"unused_attributes","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":3214,"byte_end":3865,"line_start":105,"line_end":113,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"extern \"C\" {","highlight_start":1,"highlight_end":13},{"text":"    fn ocall_save_to_memory(ptr: *mut u64, data_ptr: *const u8, data_len: usize) -> sgx_status_t;","highlight_start":1,"highlight_end":98},{"text":"    fn allocate_oram_storage(count: u64, data_size: u64, meta_size: u64, id_out: *mut u64) -> sgx_status_t;","highlight_start":1,"highlight_end":108},{"text":"    fn release_oram_storage(id: u64) -> sgx_status_t;","highlight_start":1,"highlight_end":54},{"text":"    fn checkout_oram_storage( id: u64, idx: *const u64, idx_len: usize, databuf: *mut u64,","highlight_start":1,"highlight_end":91},{"text":"        databuf_len: usize, metabuf: *mut u64, metabuf_len: usize) -> sgx_status_t;","highlight_start":1,"highlight_end":84},{"text":"    fn checkin_oram_storage( id: u64, idx: *const u64, idx_len: usize, databuf: *const u64,","highlight_start":1,"highlight_end":92},{"text":"                                databuf_len: usize, metabuf: *const u64, metabuf_len: usize) -> sgx_status_t;","highlight_start":1,"highlight_end":110},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"not a free function, impl method or static","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":3201,"byte_end":3213,"line_start":104,"line_end":104,"column_start":1,"column_end":13,"is_primary":true,"text":[{"text":"#[no_mangle]","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_attributes)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!","code":null,"level":"warning","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: attribute should be applied to a free function, impl method or static\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:104:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m#[no_mangle]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mextern \"C\" {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m106\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn ocall_save_to_memory(ptr: *mut u64, data_ptr: *const u8, data_len: usize) -> sgx_status_t;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m107\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn allocate_oram_storage(count: u64, data_size: u64, meta_size: u64, id_out: *mut u64) -> sgx_status_t;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn release_oram_storage(id: u64) -> sgx_status_t;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                databuf_len: usize, metabuf: *const u64, metabuf_len: usize) -> sgx_status_t;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mnot a free function, impl method or static\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_attributes)]` on by default\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\u001b[0m\n\n"}
 {"message":"unused import: `ORAMStorageCreator`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/heatmap.rs","byte_start":426,"byte_end":444,"line_start":15,"line_end":15,"column_start":49,"column_end":67,"is_primary":true,"text":[{"text":"use mc_oblivious_traits::{rng_maker,ORAMCreator,ORAMStorageCreator,ORAM};","highlight_start":49,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `ORAMStorageCreator`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/heatmap.rs:15:49\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse mc_oblivious_traits::{rng_maker,ORAMCreator,ORAMStorageCreator,ORAM};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
-{"message":"unused variable: `val`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/heatmap.rs","byte_start":8199,"byte_end":8202,"line_start":214,"line_end":214,"column_start":32,"column_end":35,"is_primary":true,"text":[{"text":"fn u64_a64<N: ArrayLength<u8>>(val: A64Bytes<N>) -> u64 {","highlight_start":32,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/heatmap.rs","byte_start":8199,"byte_end":8202,"line_start":214,"line_end":214,"column_start":32,"column_end":35,"is_primary":true,"text":[{"text":"fn u64_a64<N: ArrayLength<u8>>(val: A64Bytes<N>) -> u64 {","highlight_start":32,"highlight_end":35}],"label":null,"suggested_replacement":"_val","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `val`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/heatmap.rs:214:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m214\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mfn u64_a64<N: ArrayLength<u8>>(val: A64Bytes<N>) -> u64 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_val`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_variables)]` on by default\u001b[0m\n\n"}
-{"message":"unused variable: `e`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/multipart_data.rs","byte_start":16935,"byte_end":16936,"line_start":393,"line_end":393,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"            Err(e) => {","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/multipart_data.rs","byte_start":16935,"byte_end":16936,"line_start":393,"line_end":393,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"            Err(e) => {","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":"_e","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `e`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/multipart_data.rs:393:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m393\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            Err(e) => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_e`\u001b[0m\n\n"}
-{"message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"src/heatmap.rs","byte_start":5955,"byte_end":5968,"line_start":158,"line_end":158,"column_start":17,"column_end":30,"is_primary":true,"text":[{"text":"            let mut bin_count = u64_a64(oram.read(oram_index))+1;","highlight_start":17,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_mut)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"src/heatmap.rs","byte_start":5955,"byte_end":5959,"line_start":158,"line_end":158,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"            let mut bin_count = u64_a64(oram.read(oram_index))+1;","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/heatmap.rs:158:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m158\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let mut bin_count = u64_a64(oram.read(oram_index))+1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_mut)]` on by default\u001b[0m\n\n"}
-{"message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"src/heatmap.rs","byte_start":8234,"byte_end":8247,"line_start":215,"line_end":215,"column_start":9,"column_end":22,"is_primary":true,"text":[{"text":"    let mut val_slice: [u8; 8] = [0;8];","highlight_start":9,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"src/heatmap.rs","byte_start":8234,"byte_end":8238,"line_start":215,"line_end":215,"column_start":9,"column_end":13,"is_primary":true,"text":[{"text":"    let mut val_slice: [u8; 8] = [0;8];","highlight_start":9,"highlight_end":13}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/heatmap.rs:215:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m215\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let mut val_slice: [u8; 8] = [0;8];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\n"}
-{"message":"call to unsafe function is unsafe and requires unsafe function or block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe function or block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"error","spans":[{"file_name":"src/crypto/asymmetric.rs","byte_start":5409,"byte_end":5442,"line_start":116,"line_end":116,"column_start":85,"column_end":118,"is_primary":true,"text":[{"text":"        let encode_defunct = format!(\"Ethereum Signed Message:\\n{}{}\",message.len(),str::from_utf8_unchecked(message));","highlight_start":85,"highlight_end":118}],"label":"call to unsafe function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consult the function's documentation for information on how to avoid undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0133]\u001b[0m\u001b[0m\u001b[1m: call to unsafe function is unsafe and requires unsafe function or block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/crypto/asymmetric.rs:116:85\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m116\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let encode_defunct = format!(\"Ethereum Signed Message:\\n{}{}\",message.len(),str::from_utf8_unchecked(message));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcall to unsafe function\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consult the function's documentation for information on how to avoid undefined behavior\u001b[0m\n\n"}
-{"message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":8221,"byte_end":8227,"line_start":251,"line_end":251,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    unsafe { std::ptr::copy( &heatmap_len, out_ptr_size, 1) }","highlight_start":5,"highlight_end":11}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":7412,"byte_end":7561,"line_start":227,"line_end":230,"column_start":1,"column_end":47,"is_primary":false,"text":[{"text":"pub unsafe extern \"C\" fn ecall_retrieve_heatmap(","highlight_start":1,"highlight_end":49},{"text":"    sig: &mut [u8; 65],","highlight_start":1,"highlight_end":24},{"text":"    serialized_ptr: *mut u64,","highlight_start":1,"highlight_end":30},{"text":"    out_ptr_size: *mut usize) -> EnclaveReturn {","highlight_start":1,"highlight_end":47}],"label":"because it's nested under this `unsafe` fn","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_unsafe)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:251:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m227\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub unsafe extern \"C\" fn ecall_retrieve_heatmap(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m228\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    sig: &mut [u8; 65],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m229\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    serialized_ptr: *mut u64,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m230\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    out_ptr_size: *mut usize) -> EnclaveReturn {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|______________________________________________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mbecause it's nested under this `unsafe` fn\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m251\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m    unsafe { std::ptr::copy( &heatmap_len, out_ptr_size, 1) }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_unsafe)]` on by default\u001b[0m\n\n"}
-{"message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":9635,"byte_end":9641,"line_start":299,"line_end":299,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    unsafe { std::ptr::copy( &data_len, out_ptr_size, 1) }","highlight_start":5,"highlight_end":11}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":8836,"byte_end":8985,"line_start":274,"line_end":277,"column_start":1,"column_end":47,"is_primary":false,"text":[{"text":"pub unsafe extern \"C\" fn ecall_get_enclave_data(","highlight_start":1,"highlight_end":49},{"text":"    sig: &mut [u8; 65],","highlight_start":1,"highlight_end":24},{"text":"    serialized_ptr: *mut u64,","highlight_start":1,"highlight_end":30},{"text":"    out_ptr_size: *mut usize) -> EnclaveReturn {","highlight_start":1,"highlight_end":47}],"label":"because it's nested under this `unsafe` fn","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:299:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m274\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub unsafe extern \"C\" fn ecall_get_enclave_data(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m275\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    sig: &mut [u8; 65],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m276\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    serialized_ptr: *mut u64,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m277\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    out_ptr_size: *mut usize) -> EnclaveReturn {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|______________________________________________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mbecause it's nested under this `unsafe` fn\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m299\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m    unsafe { std::ptr::copy( &data_len, out_ptr_size, 1) }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
-{"message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":11188,"byte_end":11194,"line_start":348,"line_end":348,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    unsafe { std::ptr::copy( &data_len, out_ptr_size, 1) }","highlight_start":5,"highlight_end":11}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":10400,"byte_end":10547,"line_start":324,"line_end":327,"column_start":1,"column_end":47,"is_primary":false,"text":[{"text":"pub unsafe extern \"C\" fn ecall_get_audit_data(","highlight_start":1,"highlight_end":47},{"text":"    sig: &mut [u8; 65],","highlight_start":1,"highlight_end":24},{"text":"    serialized_ptr: *mut u64,","highlight_start":1,"highlight_end":30},{"text":"    out_ptr_size: *mut usize) -> EnclaveReturn {","highlight_start":1,"highlight_end":47}],"label":"because it's nested under this `unsafe` fn","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:348:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m324\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub unsafe extern \"C\" fn ecall_get_audit_data(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m325\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    sig: &mut [u8; 65],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m326\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    serialized_ptr: *mut u64,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m327\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    out_ptr_size: *mut usize) -> EnclaveReturn {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|______________________________________________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mbecause it's nested under this `unsafe` fn\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m348\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m    unsafe { std::ptr::copy( &data_len, out_ptr_size, 1) }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
-{"message":"aborting due to previous error; 22 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to previous error; 22 warnings emitted\u001b[0m\n\n"}
-{"message":"For more information about this error, try `rustc --explain E0133`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0133`.\u001b[0m\n"}
+{"message":"unused variable: `r`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":12334,"byte_end":12335,"line_start":386,"line_end":386,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"        Err(r) => {","highlight_start":13,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":12334,"byte_end":12335,"line_start":386,"line_end":386,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"        Err(r) => {","highlight_start":13,"highlight_end":14}],"label":null,"suggested_replacement":"_r","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `r`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:386:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m386\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        Err(r) => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_r`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_variables)]` on by default\u001b[0m\n\n"}
+{"message":"unused variable: `val`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/heatmap.rs","byte_start":8574,"byte_end":8577,"line_start":217,"line_end":217,"column_start":32,"column_end":35,"is_primary":true,"text":[{"text":"fn u64_a64<N: ArrayLength<u8>>(val: A64Bytes<N>) -> u64 {","highlight_start":32,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/heatmap.rs","byte_start":8574,"byte_end":8577,"line_start":217,"line_end":217,"column_start":32,"column_end":35,"is_primary":true,"text":[{"text":"fn u64_a64<N: ArrayLength<u8>>(val: A64Bytes<N>) -> u64 {","highlight_start":32,"highlight_end":35}],"label":null,"suggested_replacement":"_val","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `val`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/heatmap.rs:217:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m217\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mfn u64_a64<N: ArrayLength<u8>>(val: A64Bytes<N>) -> u64 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_val`\u001b[0m\n\n"}
+{"message":"unused variable: `n`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/traits.rs","byte_start":1987,"byte_end":1988,"line_start":55,"line_end":55,"column_start":21,"column_end":22,"is_primary":true,"text":[{"text":"                let n = u16::from_str_radix(&address_hash[index..index + 1], 16).unwrap();","highlight_start":21,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/traits.rs","byte_start":1987,"byte_end":1988,"line_start":55,"line_end":55,"column_start":21,"column_end":22,"is_primary":true,"text":[{"text":"                let n = u16::from_str_radix(&address_hash[index..index + 1], 16).unwrap();","highlight_start":21,"highlight_end":22}],"label":null,"suggested_replacement":"_n","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `n`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/traits.rs:55:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                let n = u16::from_str_radix(&address_hash[index..index + 1], 16).unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_n`\u001b[0m\n\n"}
+{"message":"unused variable: `e`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/multipart_data.rs","byte_start":17316,"byte_end":17317,"line_start":398,"line_end":398,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"            Err(e) => {","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/multipart_data.rs","byte_start":17316,"byte_end":17317,"line_start":398,"line_end":398,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"            Err(e) => {","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":"_e","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `e`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/multipart_data.rs:398:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m398\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            Err(e) => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_e`\u001b[0m\n\n"}
+{"message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"src/heatmap.rs","byte_start":6012,"byte_end":6025,"line_start":158,"line_end":158,"column_start":17,"column_end":30,"is_primary":true,"text":[{"text":"            let mut bin_count = u64_a64(oram.read(oram_index))+1;","highlight_start":17,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_mut)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"src/heatmap.rs","byte_start":6012,"byte_end":6016,"line_start":158,"line_end":158,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"            let mut bin_count = u64_a64(oram.read(oram_index))+1;","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/heatmap.rs:158:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m158\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let mut bin_count = u64_a64(oram.read(oram_index))+1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_mut)]` on by default\u001b[0m\n\n"}
+{"message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"src/heatmap.rs","byte_start":8609,"byte_end":8622,"line_start":218,"line_end":218,"column_start":9,"column_end":22,"is_primary":true,"text":[{"text":"    let mut val_slice: [u8; 8] = [0;8];","highlight_start":9,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"src/heatmap.rs","byte_start":8609,"byte_end":8613,"line_start":218,"line_end":218,"column_start":9,"column_end":13,"is_primary":true,"text":[{"text":"    let mut val_slice: [u8; 8] = [0;8];","highlight_start":9,"highlight_end":13}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/heatmap.rs:218:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m218\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let mut val_slice: [u8; 8] = [0;8];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\n"}
+{"message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":8095,"byte_end":8101,"line_start":249,"line_end":249,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    unsafe { std::ptr::copy( &heatmap_len, out_ptr_size, 1) }","highlight_start":5,"highlight_end":11}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":7286,"byte_end":7435,"line_start":225,"line_end":228,"column_start":1,"column_end":47,"is_primary":false,"text":[{"text":"pub unsafe extern \"C\" fn ecall_retrieve_heatmap(","highlight_start":1,"highlight_end":49},{"text":"    sig: &mut [u8; 65],","highlight_start":1,"highlight_end":24},{"text":"    serialized_ptr: *mut u64,","highlight_start":1,"highlight_end":30},{"text":"    out_ptr_size: *mut usize) -> EnclaveReturn {","highlight_start":1,"highlight_end":47}],"label":"because it's nested under this `unsafe` fn","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_unsafe)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:249:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m225\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub unsafe extern \"C\" fn ecall_retrieve_heatmap(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m226\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    sig: &mut [u8; 65],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m227\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    serialized_ptr: *mut u64,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m228\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    out_ptr_size: *mut usize) -> EnclaveReturn {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|______________________________________________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mbecause it's nested under this `unsafe` fn\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m249\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m    unsafe { std::ptr::copy( &heatmap_len, out_ptr_size, 1) }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_unsafe)]` on by default\u001b[0m\n\n"}
+{"message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":9509,"byte_end":9515,"line_start":297,"line_end":297,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    unsafe { std::ptr::copy( &data_len, out_ptr_size, 1) }","highlight_start":5,"highlight_end":11}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":8710,"byte_end":8859,"line_start":272,"line_end":275,"column_start":1,"column_end":47,"is_primary":false,"text":[{"text":"pub unsafe extern \"C\" fn ecall_get_enclave_data(","highlight_start":1,"highlight_end":49},{"text":"    sig: &mut [u8; 65],","highlight_start":1,"highlight_end":24},{"text":"    serialized_ptr: *mut u64,","highlight_start":1,"highlight_end":30},{"text":"    out_ptr_size: *mut usize) -> EnclaveReturn {","highlight_start":1,"highlight_end":47}],"label":"because it's nested under this `unsafe` fn","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:297:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m272\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub unsafe extern \"C\" fn ecall_get_enclave_data(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m273\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    sig: &mut [u8; 65],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m274\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    serialized_ptr: *mut u64,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m275\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    out_ptr_size: *mut usize) -> EnclaveReturn {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|______________________________________________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mbecause it's nested under this `unsafe` fn\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m297\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m    unsafe { std::ptr::copy( &data_len, out_ptr_size, 1) }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
+{"message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":11066,"byte_end":11072,"line_start":346,"line_end":346,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    unsafe { std::ptr::copy( &data_len, out_ptr_size, 1) }","highlight_start":5,"highlight_end":11}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":10278,"byte_end":10425,"line_start":322,"line_end":325,"column_start":1,"column_end":47,"is_primary":false,"text":[{"text":"pub unsafe extern \"C\" fn ecall_get_audit_data(","highlight_start":1,"highlight_end":47},{"text":"    sig: &mut [u8; 65],","highlight_start":1,"highlight_end":24},{"text":"    serialized_ptr: *mut u64,","highlight_start":1,"highlight_end":30},{"text":"    out_ptr_size: *mut usize) -> EnclaveReturn {","highlight_start":1,"highlight_end":47}],"label":"because it's nested under this `unsafe` fn","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:346:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m322\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub unsafe extern \"C\" fn ecall_get_audit_data(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m323\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    sig: &mut [u8; 65],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m324\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    serialized_ptr: *mut u64,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m325\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    out_ptr_size: *mut usize) -> EnclaveReturn {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|______________________________________________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mbecause it's nested under this `unsafe` fn\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m346\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m    unsafe { std::ptr::copy( &data_len, out_ptr_size, 1) }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
+{"message":"constant is never used: `TIMEFRAME_GRANULARITY`","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/heatmap.rs","byte_start":1305,"byte_end":1349,"line_start":38,"line_end":38,"column_start":1,"column_end":45,"is_primary":true,"text":[{"text":"pub const TIMEFRAME_GRANULARITY: f64 = 10.0; // this is in minutes","highlight_start":1,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(dead_code)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: constant is never used: `TIMEFRAME_GRANULARITY`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/heatmap.rs:38:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub const TIMEFRAME_GRANULARITY: f64 = 10.0; // this is in minutes\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(dead_code)]` on by default\u001b[0m\n\n"}
+{"message":"function is never used: `strip_heatmap`","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/heatmap.rs","byte_start":2667,"byte_end":2680,"line_start":70,"line_end":70,"column_start":8,"column_end":21,"is_primary":true,"text":[{"text":"pub fn strip_heatmap(x: HashMap<String, u16>) -> HashMap<String, u16> {","highlight_start":8,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: function is never used: `strip_heatmap`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/heatmap.rs:70:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m70\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub fn strip_heatmap(x: HashMap<String, u16>) -> HashMap<String, u16> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\n\n"}
+{"message":"associated function is never used: `recover`","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/crypto/asymmetric.rs","byte_start":6728,"byte_end":6735,"line_start":147,"line_end":147,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"    pub fn recover(message: &[u8], sig: [u8;65]) -> Result<[u8; 64], CryptoError> {","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: associated function is never used: `recover`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/crypto/asymmetric.rs:147:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m147\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    pub fn recover(message: &[u8], sig: [u8;65]) -> Result<[u8; 64], CryptoError> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
+{"message":"associated function is never used: `from_hex`","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/crypto/hash.rs","byte_start":1732,"byte_end":1740,"line_start":41,"line_end":41,"column_start":12,"column_end":20,"is_primary":true,"text":[{"text":"    pub fn from_hex(hex: &str) -> Result<Self, FromHexError> {","highlight_start":12,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: associated function is never used: `from_hex`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/crypto/hash.rs:41:12\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    pub fn from_hex(hex: &str) -> Result<Self, FromHexError> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n\n"}
+{"message":"associated function is never used: `is_zero`","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/crypto/hash.rs","byte_start":2117,"byte_end":2124,"line_start":52,"line_end":52,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"    pub fn is_zero(&self) -> bool {","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: associated function is never used: `is_zero`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/crypto/hash.rs:52:12\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    pub fn is_zero(&self) -> bool {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
+{"message":"type alias is never used: `IV`","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/crypto/symmetric.rs","byte_start":318,"byte_end":342,"line_start":15,"line_end":15,"column_start":1,"column_end":25,"is_primary":true,"text":[{"text":"type IV = [u8; IV_SIZE];","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: type alias is never used: `IV`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/crypto/symmetric.rs:15:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mtype IV = [u8; IV_SIZE];\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
+{"message":"function is never used: `encrypt`","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/crypto/symmetric.rs","byte_start":986,"byte_end":993,"line_start":36,"line_end":36,"column_start":8,"column_end":15,"is_primary":true,"text":[{"text":"pub fn encrypt(message: &[u8], key: &SymmetricKey) -> Result<Vec<u8>, CryptoError> { encrypt_with_nonce(message, key, None) }","highlight_start":8,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: function is never used: `encrypt`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/crypto/symmetric.rs:36:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m36\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub fn encrypt(message: &[u8], key: &SymmetricKey) -> Result<Vec<u8>, CryptoError> { encrypt_with_nonce(message, key, None) }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
+{"message":"function is never used: `encrypt_with_nonce`","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/crypto/symmetric.rs","byte_start":1451,"byte_end":1469,"line_start":41,"line_end":41,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"pub fn encrypt_with_nonce(message: &[u8], key: &SymmetricKey, _iv: Option<IV>) -> Result<Vec<u8>, CryptoError> {","highlight_start":8,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: function is never used: `encrypt_with_nonce`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/crypto/symmetric.rs:41:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub fn encrypt_with_nonce(message: &[u8], key: &SymmetricKey, _iv: Option<IV>) -> Result<Vec<u8>, CryptoError> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
+{"message":"function is never used: `load_sealed_key`","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/storage.rs","byte_start":3914,"byte_end":3929,"line_start":97,"line_end":97,"column_start":8,"column_end":23,"is_primary":true,"text":[{"text":"pub fn load_sealed_key(path: &str, sealed_key: &mut [u8]) {","highlight_start":8,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: function is never used: `load_sealed_key`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/storage.rs:97:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub fn load_sealed_key(path: &str, sealed_key: &mut [u8]) {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\n\n"}
+{"message":"function is never used: `allocate_oram_storage`","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":3329,"byte_end":3432,"line_start":107,"line_end":107,"column_start":5,"column_end":108,"is_primary":true,"text":[{"text":"    fn allocate_oram_storage(count: u64, data_size: u64, meta_size: u64, id_out: *mut u64) -> sgx_status_t;","highlight_start":5,"highlight_end":108}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: function is never used: `allocate_oram_storage`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:107:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m107\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn allocate_oram_storage(count: u64, data_size: u64, meta_size: u64, id_out: *mut u64) -> sgx_status_t;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
+{"message":"function is never used: `release_oram_storage`","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":3437,"byte_end":3486,"line_start":108,"line_end":108,"column_start":5,"column_end":54,"is_primary":true,"text":[{"text":"    fn release_oram_storage(id: u64) -> sgx_status_t;","highlight_start":5,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: function is never used: `release_oram_storage`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:108:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn release_oram_storage(id: u64) -> sgx_status_t;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
+{"message":"function is never used: `checkout_oram_storage`","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":3491,"byte_end":3661,"line_start":109,"line_end":110,"column_start":5,"column_end":84,"is_primary":true,"text":[{"text":"    fn checkout_oram_storage( id: u64, idx: *const u64, idx_len: usize, databuf: *mut u64,","highlight_start":5,"highlight_end":91},{"text":"        databuf_len: usize, metabuf: *mut u64, metabuf_len: usize) -> sgx_status_t;","highlight_start":1,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: function is never used: `checkout_oram_storage`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:109:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn checkout_oram_storage( id: u64, idx: *const u64, idx_len: usize, databuf: *mut u64,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        databuf_len: usize, metabuf: *mut u64, metabuf_len: usize) -> sgx_status_t;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|___________________________________________________________________________________^\u001b[0m\n\n"}
+{"message":"function is never used: `checkin_oram_storage`","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":3666,"byte_end":3863,"line_start":111,"line_end":112,"column_start":5,"column_end":110,"is_primary":true,"text":[{"text":"    fn checkin_oram_storage( id: u64, idx: *const u64, idx_len: usize, databuf: *const u64,","highlight_start":5,"highlight_end":92},{"text":"                                databuf_len: usize, metabuf: *const u64, metabuf_len: usize) -> sgx_status_t;","highlight_start":1,"highlight_end":110}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: function is never used: `checkin_oram_storage`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:111:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn checkin_oram_storage( id: u64, idx: *const u64, idx_len: usize, databuf: *const u64,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                databuf_len: usize, metabuf: *const u64, metabuf_len: usize) -> sgx_status_t;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________________________________________________________________________________________________________^\u001b[0m\n\n"}
+{"message":"panic message is not a string literal","code":{"code":"non_fmt_panics","explanation":null},"level":"warning","spans":[{"file_name":"src/storage.rs","byte_start":2817,"byte_end":2820,"line_start":67,"line_end":67,"column_start":28,"column_end":31,"is_primary":true,"text":[{"text":"                    panic!(err)","highlight_start":28,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(non_fmt_panics)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"this usage of panic!() is deprecated; it will be a hard error in Rust 2021","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add a \"{}\" format string to Display the message","code":null,"level":"help","spans":[{"file_name":"src/storage.rs","byte_start":2817,"byte_end":2817,"line_start":67,"line_end":67,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"                    panic!(err)","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":"\"{}\", ","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"or use std::panic::panic_any instead","code":null,"level":"help","spans":[{"file_name":"src/storage.rs","byte_start":2810,"byte_end":2816,"line_start":67,"line_end":67,"column_start":21,"column_end":27,"is_primary":true,"text":[{"text":"                    panic!(err)","highlight_start":21,"highlight_end":27}],"label":null,"suggested_replacement":"std::panic::panic_any","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: panic message is not a string literal\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/storage.rs:67:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m67\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    panic!(err)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(non_fmt_panics)]` on by default\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this usage of panic!() is deprecated; it will be a hard error in Rust 2021\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: add a \"{}\" format string to Display the message\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m67\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    panic!(\u001b[0m\u001b[0m\u001b[38;5;10m\"{}\", \u001b[0m\u001b[0merr)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: or use std::panic::panic_any instead\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m67\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10mstd::panic::panic_any\u001b[0m\u001b[0m(err)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
+{"message":"structure field `startTS` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"src/heatmap.rs","byte_start":1512,"byte_end":1519,"line_start":45,"line_end":45,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"    startTS: u64,","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(non_snake_case)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"src/heatmap.rs","byte_start":1512,"byte_end":1519,"line_start":45,"line_end":45,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"    startTS: u64,","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":"start_ts","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: structure field `startTS` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/heatmap.rs:45:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    startTS: u64,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `start_ts`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(non_snake_case)]` on by default\u001b[0m\n\n"}
+{"message":"structure field `endTS` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"src/heatmap.rs","byte_start":1530,"byte_end":1535,"line_start":46,"line_end":46,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    endTS: u64,","highlight_start":5,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"src/heatmap.rs","byte_start":1530,"byte_end":1535,"line_start":46,"line_end":46,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    endTS: u64,","highlight_start":5,"highlight_end":10}],"label":null,"suggested_replacement":"end_ts","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: structure field `endTS` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/heatmap.rs:46:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    endTS: u64,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `end_ts`\u001b[0m\n\n"}
+{"message":"structure field `testResult` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"src/heatmap.rs","byte_start":1546,"byte_end":1556,"line_start":47,"line_end":47,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    testResult: bool","highlight_start":5,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"src/heatmap.rs","byte_start":1546,"byte_end":1556,"line_start":47,"line_end":47,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    testResult: bool","highlight_start":5,"highlight_end":15}],"label":null,"suggested_replacement":"test_result","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: structure field `testResult` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/heatmap.rs:47:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    testResult: bool\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `test_result`\u001b[0m\n\n"}
+{"message":"variable `dhKey` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"src/heatmap.rs","byte_start":3812,"byte_end":3817,"line_start":100,"line_end":100,"column_start":58,"column_end":63,"is_primary":true,"text":[{"text":"pub fn add_personal_data_internal(encrypted_data: &[u8], dhKey: &DhKey, publickey: String)  -> Result<(), EnclaveError> {","highlight_start":58,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"src/heatmap.rs","byte_start":3812,"byte_end":3817,"line_start":100,"line_end":100,"column_start":58,"column_end":63,"is_primary":true,"text":[{"text":"pub fn add_personal_data_internal(encrypted_data: &[u8], dhKey: &DhKey, publickey: String)  -> Result<(), EnclaveError> {","highlight_start":58,"highlight_end":63}],"label":null,"suggested_replacement":"dh_key","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable `dhKey` should have a snake case name\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/heatmap.rs:100:58\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m100\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub fn add_personal_data_internal(encrypted_data: &[u8], dhKey: &DhKey, publickey: String)  -> Result<(), EnclaveError> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                         \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `dh_key`\u001b[0m\n\n"}
+{"message":"unused `Result` that must be used","code":{"code":"unused_must_use","explanation":null},"level":"warning","spans":[{"file_name":"src/storage.rs","byte_start":5089,"byte_end":5114,"line_start":126,"line_end":126,"column_start":21,"column_end":46,"is_primary":true,"text":[{"text":"                    remove_file(sealed_path);","highlight_start":21,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_must_use)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"this `Result` may be an `Err` variant, which should be handled","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused `Result` that must be used\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/storage.rs:126:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m126\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    remove_file(sealed_path);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_must_use)]` on by default\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this `Result` may be an `Err` variant, which should be handled\u001b[0m\n\n"}
+{"message":"46 warnings emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: 46 warnings emitted\u001b[0m\n\n"}
Index: enclave/enclave/Cargo.lock
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/enclave/enclave/Cargo.lock b/enclave/enclave/Cargo.lock
--- a/enclave/enclave/Cargo.lock	
+++ b/enclave/enclave/Cargo.lock	(date 1664077232335)
@@ -717,36 +717,6 @@
 name = "sgx_urts"
 version = "1.1.4"
 
-[[patch.unused]]
-name = "byteorder"
-version = "1.4.3"
-source = "git+https://github.com/njeans/byteorder-sgx#3fee47f621fd951395c114b56b93e6dc37b4c1b6"
-
-[[patch.unused]]
-name = "curve25519-dalek"
-version = "4.0.0-pre.1"
-source = "git+https://github.com/dalek-cryptography/curve25519-dalek?tag=4.0.0-pre.1#df4e2fa12966fb982c09b32f3732bfcffae378bf"
-
-[[patch.unused]]
-name = "ed25519-dalek"
-version = "2.0.0-pre.0"
-source = "git+https://github.com/mobilecoinfoundation/ed25519-dalek.git?rev=78bdc2a0b0af852cb4e47a0ca9be74bdf77c57b6#78bdc2a0b0af852cb4e47a0ca9be74bdf77c57b6"
-
-[[patch.unused]]
-name = "schnorrkel-og"
-version = "0.10.2"
-source = "git+https://github.com/mobilecoinfoundation/schnorrkel.git?rev=9b48418556b0af476be2313309bc5a23fb8b351d#9b48418556b0af476be2313309bc5a23fb8b351d"
-
-[[patch.unused]]
-name = "serde_bytes"
-version = "0.11.5"
-source = "git+https://github.com/njeans/serde-bytes-sgx.git#dda26a12db836157db90914818ce9dc7f71f27f0"
-
-[[patch.unused]]
-name = "x25519-dalek"
-version = "2.0.0-pre.0"
-source = "git+https://github.com/mobilecoinfoundation/x25519-dalek.git?rev=672f29ef4b3addd9a3c4888cf4b836b243bda595#672f29ef4b3addd9a3c4888cf4b836b243bda595"
-
 [[patch.unused]]
 name = "sgx_cov"
 version = "1.1.4"
@@ -794,3 +764,33 @@
 [[patch.unused]]
 name = "sgx_urts"
 version = "1.1.4"
+
+[[patch.unused]]
+name = "byteorder"
+version = "1.4.3"
+source = "git+https://github.com/njeans/byteorder-sgx#3fee47f621fd951395c114b56b93e6dc37b4c1b6"
+
+[[patch.unused]]
+name = "curve25519-dalek"
+version = "4.0.0-pre.1"
+source = "git+https://github.com/dalek-cryptography/curve25519-dalek?tag=4.0.0-pre.1#df4e2fa12966fb982c09b32f3732bfcffae378bf"
+
+[[patch.unused]]
+name = "ed25519-dalek"
+version = "2.0.0-pre.0"
+source = "git+https://github.com/mobilecoinfoundation/ed25519-dalek.git?rev=78bdc2a0b0af852cb4e47a0ca9be74bdf77c57b6#78bdc2a0b0af852cb4e47a0ca9be74bdf77c57b6"
+
+[[patch.unused]]
+name = "schnorrkel-og"
+version = "0.10.2"
+source = "git+https://github.com/mobilecoinfoundation/schnorrkel.git?rev=9b48418556b0af476be2313309bc5a23fb8b351d#9b48418556b0af476be2313309bc5a23fb8b351d"
+
+[[patch.unused]]
+name = "serde_bytes"
+version = "0.11.5"
+source = "git+https://github.com/njeans/serde-bytes-sgx.git#dda26a12db836157db90914818ce9dc7f71f27f0"
+
+[[patch.unused]]
+name = "x25519-dalek"
+version = "2.0.0-pre.0"
+source = "git+https://github.com/mobilecoinfoundation/x25519-dalek.git?rev=672f29ef4b3addd9a3c4888cf4b836b243bda595#672f29ef4b3addd9a3c4888cf4b836b243bda595"
